// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package parser // BSLParser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type BSLParser struct {
	*antlr.BaseParser
}

var bslparserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func bslparserParserInit() {
	staticData := &bslparserParserStaticData
	staticData.literalNames = []string{
		"", "", "", "'.'", "'['", "']'", "", "", "':'", "';'", "','", "'='",
		"'+'", "'-'", "'<='", "'<>'", "'<'", "'>='", "'>'", "'*'", "'/'", "'%'",
		"'?'", "'&'", "", "", "", "'#'", "'|'", "'~'", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "'!'",
	}
	staticData.symbolicNames = []string{
		"", "LINE_COMMENT", "WHITE_SPACE", "DOT", "LBRACK", "RBRACK", "LPAREN",
		"RPAREN", "COLON", "SEMICOLON", "COMMA", "ASSIGN", "PLUS", "MINUS",
		"LESS_OR_EQUAL", "NOT_EQUAL", "LESS", "GREATER_OR_EQUAL", "GREATER",
		"MUL", "QUOTIENT", "MODULO", "QUESTION", "AMPERSAND", "PREPROC_DELETE",
		"PREPROC_INSERT", "PREPROC_ENDINSERT", "HASH", "BAR", "TILDA", "TRUE",
		"FALSE", "UNDEFINED", "NULL", "DECIMAL", "DATETIME", "FLOAT", "STRING",
		"STRINGSTART", "STRINGTAIL", "STRINGPART", "PROCEDURE_KEYWORD", "FUNCTION_KEYWORD",
		"ENDPROCEDURE_KEYWORD", "ENDFUNCTION_KEYWORD", "EXPORT_KEYWORD", "VAL_KEYWORD",
		"ENDIF_KEYWORD", "ENDDO_KEYWORD", "IF_KEYWORD", "ELSIF_KEYWORD", "ELSE_KEYWORD",
		"THEN_KEYWORD", "WHILE_KEYWORD", "DO_KEYWORD", "FOR_KEYWORD", "TO_KEYWORD",
		"EACH_KEYWORD", "IN_KEYWORD", "TRY_KEYWORD", "EXCEPT_KEYWORD", "ENDTRY_KEYWORD",
		"RETURN_KEYWORD", "CONTINUE_KEYWORD", "RAISE_KEYWORD", "VAR_KEYWORD",
		"NOT_KEYWORD", "OR_KEYWORD", "AND_KEYWORD", "NEW_KEYWORD", "GOTO_KEYWORD",
		"BREAK_KEYWORD", "EXECUTE_KEYWORD", "ADDHANDLER_KEYWORD", "REMOVEHANDLER_KEYWORD",
		"ASYNC_KEYWORD", "IDENTIFIER", "UNKNOWN", "PREPROC_EXCLAMATION_MARK",
		"PREPROC_LPAREN", "PREPROC_RPAREN", "PREPROC_STRING", "PREPROC_USE_KEYWORD",
		"PREPROC_REGION", "PREPROC_END_REGION", "PREPROC_NOT_KEYWORD", "PREPROC_OR_KEYWORD",
		"PREPROC_AND_KEYWORD", "PREPROC_IF_KEYWORD", "PREPROC_THEN_KEYWORD",
		"PREPROC_ELSIF_KEYWORD", "PREPROC_ENDIF_KEYWORD", "PREPROC_ELSE_KEYWORD",
		"PREPROC_MOBILEAPPCLIENT_SYMBOL", "PREPROC_MOBILEAPPSERVER_SYMBOL",
		"PREPROC_MOBILECLIENT_SYMBOL", "PREPROC_THICKCLIENTORDINARYAPPLICATION_SYMBOL",
		"PREPROC_THICKCLIENTMANAGEDAPPLICATION_SYMBOL", "PREPROC_EXTERNALCONNECTION_SYMBOL",
		"PREPROC_THINCLIENT_SYMBOL", "PREPROC_WEBCLIENT_SYMBOL", "PREPROC_ATCLIENT_SYMBOL",
		"PREPROC_CLIENT_SYMBOL", "PREPROC_ATSERVER_SYMBOL", "PREPROC_SERVER_SYMBOL",
		"PREPROC_MOBILE_STANDALONE_SERVER", "PREPROC_LINUX", "PREPROC_WINDOWS",
		"PREPROC_MACOS", "PREPROC_IDENTIFIER", "PREPROC_NEWLINE", "PREPROC_ANY",
		"ANNOTATION_ATSERVERNOCONTEXT_SYMBOL", "ANNOTATION_ATCLIENTATSERVERNOCONTEXT_SYMBOL",
		"ANNOTATION_ATCLIENTATSERVER_SYMBOL", "ANNOTATION_ATCLIENT_SYMBOL",
		"ANNOTATION_ATSERVER_SYMBOL", "ANNOTATION_BEFORE_SYMBOL", "ANNOTATION_AFTER_SYMBOL",
		"ANNOTATION_AROUND_SYMBOL", "ANNOTATION_CHANGEANDVALIDATE_SYMBOL", "ANNOTATION_CUSTOM_SYMBOL",
		"ANNOTATION_UNKNOWN", "PREPROC_ENDDELETE", "PREPROC_DELETE_ANY", "AWAIT_KEYWORD",
	}
	staticData.ruleNames = []string{
		"file", "shebang", "usedLib", "use", "regionStart", "regionEnd", "regionName",
		"preproc_if", "preproc_elsif", "preproc_else", "preproc_endif", "preproc_expression",
		"preproc_logicalOperand", "preproc_logicalExpression", "preproc_symbol",
		"preproc_unknownSymbol", "preproc_boolOperation", "preprocessor", "compilerDirectiveSymbol",
		"compilerDirective", "annotationName", "annotationParamName", "annotation",
		"annotationParams", "annotationParam", "var_name", "moduleVars", "moduleVar",
		"moduleVarsList", "moduleVarDeclaration", "subVars", "subVar", "subVarsList",
		"subVarDeclaration", "subName", "subs", "sub", "procedure", "function",
		"procDeclaration", "funcDeclaration", "subCodeBlock", "continueStatement",
		"breakStatement", "raiseStatement", "ifStatement", "ifBranch", "elsifBranch",
		"elseBranch", "whileStatement", "forStatement", "forEachStatement",
		"tryStatement", "returnStatement", "executeStatement", "callStatement",
		"waitStatement", "labelName", "label", "gotoStatement", "tryCodeBlock",
		"exceptCodeBlock", "event", "handler", "addHandlerStatement", "removeHandlerStatement",
		"ternaryOperator", "waitExpression", "fileCodeBlockBeforeSub", "fileCodeBlock",
		"codeBlock", "numeric", "paramList", "param", "defaultValue", "constValue",
		"multilineString", "string", "statement", "assignment", "callParamList",
		"callParam", "expression", "operation", "compareOperation", "boolOperation",
		"unaryModifier", "member", "newwExpression", "typeName", "methodCall",
		"globalMethodCall", "methodName", "complexIdentifier", "modifier", "acceptor",
		"lValue", "accessCall", "accessIndex", "accessProperty", "doCall", "compoundStatement",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 125, 886, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2,
		84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89,
		7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7,
		94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99,
		2, 100, 7, 100, 2, 101, 7, 101, 1, 0, 3, 0, 206, 8, 0, 1, 0, 5, 0, 209,
		8, 0, 10, 0, 12, 0, 212, 9, 0, 1, 0, 3, 0, 215, 8, 0, 1, 0, 5, 0, 218,
		8, 0, 10, 0, 12, 0, 221, 9, 0, 1, 0, 1, 0, 1, 0, 3, 0, 226, 8, 0, 1, 0,
		1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 5, 1, 234, 8, 1, 10, 1, 12, 1, 237, 9, 1,
		1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6,
		1, 7, 1, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 9, 1, 9, 1, 10, 1, 10,
		1, 11, 3, 11, 264, 8, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 271,
		8, 11, 1, 12, 1, 12, 3, 12, 275, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3,
		12, 281, 8, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 288, 8, 12, 1,
		13, 1, 13, 1, 13, 1, 13, 5, 13, 294, 8, 13, 10, 13, 12, 13, 297, 9, 13,
		1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1,
		14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 316, 8, 14, 1, 15,
		1, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1,
		17, 3, 17, 330, 8, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20,
		1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 3, 22, 344, 8, 22, 1, 23, 1, 23, 1,
		23, 1, 23, 5, 23, 350, 8, 23, 10, 23, 12, 23, 353, 9, 23, 3, 23, 355, 8,
		23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 3, 24, 362, 8, 24, 1, 24, 3, 24,
		365, 8, 24, 1, 25, 1, 25, 1, 26, 4, 26, 370, 8, 26, 11, 26, 12, 26, 371,
		1, 27, 1, 27, 1, 27, 5, 27, 377, 8, 27, 10, 27, 12, 27, 380, 9, 27, 1,
		27, 1, 27, 1, 27, 3, 27, 385, 8, 27, 1, 28, 1, 28, 1, 28, 5, 28, 390, 8,
		28, 10, 28, 12, 28, 393, 9, 28, 1, 29, 1, 29, 3, 29, 397, 8, 29, 1, 30,
		4, 30, 400, 8, 30, 11, 30, 12, 30, 401, 1, 31, 1, 31, 1, 31, 5, 31, 407,
		8, 31, 10, 31, 12, 31, 410, 9, 31, 1, 31, 1, 31, 1, 31, 3, 31, 415, 8,
		31, 1, 32, 1, 32, 1, 32, 5, 32, 420, 8, 32, 10, 32, 12, 32, 423, 9, 32,
		1, 33, 1, 33, 1, 34, 1, 34, 1, 35, 4, 35, 430, 8, 35, 11, 35, 12, 35, 431,
		1, 36, 1, 36, 3, 36, 436, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1,
		38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 5, 39, 449, 8, 39, 10, 39, 12, 39,
		452, 9, 39, 1, 39, 3, 39, 455, 8, 39, 1, 39, 1, 39, 1, 39, 1, 39, 3, 39,
		461, 8, 39, 1, 39, 1, 39, 3, 39, 465, 8, 39, 1, 40, 1, 40, 1, 40, 5, 40,
		470, 8, 40, 10, 40, 12, 40, 473, 9, 40, 1, 40, 3, 40, 476, 8, 40, 1, 40,
		1, 40, 1, 40, 1, 40, 3, 40, 482, 8, 40, 1, 40, 1, 40, 3, 40, 486, 8, 40,
		1, 41, 3, 41, 489, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1,
		44, 1, 44, 3, 44, 499, 8, 44, 1, 44, 3, 44, 502, 8, 44, 1, 45, 1, 45, 5,
		45, 506, 8, 45, 10, 45, 12, 45, 509, 9, 45, 1, 45, 3, 45, 512, 8, 45, 1,
		45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47,
		1, 47, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 51,
		1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 3, 53, 562, 8, 53, 1, 54, 1, 54,
		1, 54, 3, 54, 567, 8, 54, 1, 55, 1, 55, 3, 55, 571, 8, 55, 1, 55, 5, 55,
		574, 8, 55, 10, 55, 12, 55, 577, 9, 55, 1, 55, 1, 55, 3, 55, 581, 8, 55,
		1, 56, 1, 56, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1,
		59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 62, 1, 62, 1, 63, 1, 63, 1, 64,
		1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1,
		66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67,
		1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 5, 70, 631, 8, 70, 10, 70, 12,
		70, 634, 9, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 5, 72, 641, 8, 72, 10,
		72, 12, 72, 644, 9, 72, 1, 73, 5, 73, 647, 8, 73, 10, 73, 12, 73, 650,
		9, 73, 1, 73, 3, 73, 653, 8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 658, 8, 73,
		1, 74, 1, 74, 1, 75, 3, 75, 663, 8, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1,
		75, 1, 75, 1, 75, 3, 75, 672, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 5, 76,
		678, 8, 76, 10, 76, 12, 76, 681, 9, 76, 1, 76, 1, 76, 1, 77, 1, 77, 4,
		77, 687, 8, 77, 11, 77, 12, 77, 688, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78,
		1, 78, 3, 78, 697, 8, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 704,
		8, 78, 3, 78, 706, 8, 78, 1, 78, 3, 78, 709, 8, 78, 1, 78, 3, 78, 712,
		8, 78, 1, 79, 1, 79, 5, 79, 716, 8, 79, 10, 79, 12, 79, 719, 9, 79, 1,
		79, 1, 79, 5, 79, 723, 8, 79, 10, 79, 12, 79, 726, 9, 79, 1, 79, 1, 79,
		1, 80, 1, 80, 1, 80, 5, 80, 733, 8, 80, 10, 80, 12, 80, 736, 9, 80, 1,
		81, 3, 81, 739, 8, 81, 1, 82, 1, 82, 5, 82, 743, 8, 82, 10, 82, 12, 82,
		746, 9, 82, 1, 82, 1, 82, 5, 82, 750, 8, 82, 10, 82, 12, 82, 753, 9, 82,
		1, 82, 1, 82, 5, 82, 757, 8, 82, 10, 82, 12, 82, 760, 9, 82, 5, 82, 762,
		8, 82, 10, 82, 12, 82, 765, 9, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		83, 1, 83, 3, 83, 774, 8, 83, 1, 84, 1, 84, 1, 85, 1, 85, 1, 86, 1, 86,
		1, 87, 3, 87, 783, 8, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 1,
		87, 5, 87, 792, 8, 87, 10, 87, 12, 87, 795, 9, 87, 1, 87, 1, 87, 3, 87,
		799, 8, 87, 1, 87, 3, 87, 802, 8, 87, 1, 88, 1, 88, 1, 88, 3, 88, 807,
		8, 88, 1, 88, 1, 88, 3, 88, 811, 8, 88, 1, 89, 1, 89, 1, 90, 1, 90, 1,
		90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93,
		827, 8, 93, 1, 93, 5, 93, 830, 8, 93, 10, 93, 12, 93, 833, 9, 93, 1, 94,
		1, 94, 1, 94, 3, 94, 838, 8, 94, 1, 95, 5, 95, 841, 8, 95, 10, 95, 12,
		95, 844, 9, 95, 1, 95, 1, 95, 3, 95, 848, 8, 95, 1, 96, 1, 96, 3, 96, 852,
		8, 96, 1, 96, 3, 96, 855, 8, 96, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1,
		98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101,
		1, 101, 1, 101, 1, 101, 3, 101, 884, 8, 101, 1, 101, 0, 0, 102, 0, 2, 4,
		6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42,
		44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78,
		80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
		114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
		144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
		174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
		0, 10, 2, 0, 109, 109, 111, 111, 2, 0, 81, 81, 109, 109, 1, 0, 86, 87,
		1, 0, 112, 116, 1, 0, 117, 121, 2, 0, 34, 34, 36, 36, 1, 0, 12, 13, 2,
		0, 11, 11, 14, 18, 1, 0, 67, 68, 2, 0, 12, 13, 66, 66, 935, 0, 205, 1,
		0, 0, 0, 2, 230, 1, 0, 0, 0, 4, 238, 1, 0, 0, 0, 6, 240, 1, 0, 0, 0, 8,
		243, 1, 0, 0, 0, 10, 246, 1, 0, 0, 0, 12, 248, 1, 0, 0, 0, 14, 250, 1,
		0, 0, 0, 16, 254, 1, 0, 0, 0, 18, 258, 1, 0, 0, 0, 20, 260, 1, 0, 0, 0,
		22, 270, 1, 0, 0, 0, 24, 287, 1, 0, 0, 0, 26, 289, 1, 0, 0, 0, 28, 315,
		1, 0, 0, 0, 30, 317, 1, 0, 0, 0, 32, 319, 1, 0, 0, 0, 34, 321, 1, 0, 0,
		0, 36, 331, 1, 0, 0, 0, 38, 333, 1, 0, 0, 0, 40, 336, 1, 0, 0, 0, 42, 338,
		1, 0, 0, 0, 44, 340, 1, 0, 0, 0, 46, 345, 1, 0, 0, 0, 48, 364, 1, 0, 0,
		0, 50, 366, 1, 0, 0, 0, 52, 369, 1, 0, 0, 0, 54, 378, 1, 0, 0, 0, 56, 386,
		1, 0, 0, 0, 58, 394, 1, 0, 0, 0, 60, 399, 1, 0, 0, 0, 62, 408, 1, 0, 0,
		0, 64, 416, 1, 0, 0, 0, 66, 424, 1, 0, 0, 0, 68, 426, 1, 0, 0, 0, 70, 429,
		1, 0, 0, 0, 72, 435, 1, 0, 0, 0, 74, 437, 1, 0, 0, 0, 76, 441, 1, 0, 0,
		0, 78, 450, 1, 0, 0, 0, 80, 471, 1, 0, 0, 0, 82, 488, 1, 0, 0, 0, 84, 492,
		1, 0, 0, 0, 86, 494, 1, 0, 0, 0, 88, 496, 1, 0, 0, 0, 90, 503, 1, 0, 0,
		0, 92, 515, 1, 0, 0, 0, 94, 520, 1, 0, 0, 0, 96, 525, 1, 0, 0, 0, 98, 528,
		1, 0, 0, 0, 100, 534, 1, 0, 0, 0, 102, 544, 1, 0, 0, 0, 104, 553, 1, 0,
		0, 0, 106, 559, 1, 0, 0, 0, 108, 563, 1, 0, 0, 0, 110, 580, 1, 0, 0, 0,
		112, 582, 1, 0, 0, 0, 114, 584, 1, 0, 0, 0, 116, 586, 1, 0, 0, 0, 118,
		590, 1, 0, 0, 0, 120, 594, 1, 0, 0, 0, 122, 596, 1, 0, 0, 0, 124, 598,
		1, 0, 0, 0, 126, 600, 1, 0, 0, 0, 128, 602, 1, 0, 0, 0, 130, 607, 1, 0,
		0, 0, 132, 612, 1, 0, 0, 0, 134, 621, 1, 0, 0, 0, 136, 624, 1, 0, 0, 0,
		138, 626, 1, 0, 0, 0, 140, 632, 1, 0, 0, 0, 142, 635, 1, 0, 0, 0, 144,
		637, 1, 0, 0, 0, 146, 648, 1, 0, 0, 0, 148, 659, 1, 0, 0, 0, 150, 671,
		1, 0, 0, 0, 152, 673, 1, 0, 0, 0, 154, 686, 1, 0, 0, 0, 156, 711, 1, 0,
		0, 0, 158, 713, 1, 0, 0, 0, 160, 729, 1, 0, 0, 0, 162, 738, 1, 0, 0, 0,
		164, 740, 1, 0, 0, 0, 166, 773, 1, 0, 0, 0, 168, 775, 1, 0, 0, 0, 170,
		777, 1, 0, 0, 0, 172, 779, 1, 0, 0, 0, 174, 782, 1, 0, 0, 0, 176, 810,
		1, 0, 0, 0, 178, 812, 1, 0, 0, 0, 180, 814, 1, 0, 0, 0, 182, 817, 1, 0,
		0, 0, 184, 820, 1, 0, 0, 0, 186, 826, 1, 0, 0, 0, 188, 837, 1, 0, 0, 0,
		190, 842, 1, 0, 0, 0, 192, 851, 1, 0, 0, 0, 194, 856, 1, 0, 0, 0, 196,
		859, 1, 0, 0, 0, 198, 863, 1, 0, 0, 0, 200, 866, 1, 0, 0, 0, 202, 883,
		1, 0, 0, 0, 204, 206, 3, 2, 1, 0, 205, 204, 1, 0, 0, 0, 205, 206, 1, 0,
		0, 0, 206, 210, 1, 0, 0, 0, 207, 209, 3, 34, 17, 0, 208, 207, 1, 0, 0,
		0, 209, 212, 1, 0, 0, 0, 210, 208, 1, 0, 0, 0, 210, 211, 1, 0, 0, 0, 211,
		214, 1, 0, 0, 0, 212, 210, 1, 0, 0, 0, 213, 215, 3, 52, 26, 0, 214, 213,
		1, 0, 0, 0, 214, 215, 1, 0, 0, 0, 215, 219, 1, 0, 0, 0, 216, 218, 3, 34,
		17, 0, 217, 216, 1, 0, 0, 0, 218, 221, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0,
		219, 220, 1, 0, 0, 0, 220, 225, 1, 0, 0, 0, 221, 219, 1, 0, 0, 0, 222,
		223, 3, 136, 68, 0, 223, 224, 3, 70, 35, 0, 224, 226, 1, 0, 0, 0, 225,
		222, 1, 0, 0, 0, 225, 226, 1, 0, 0, 0, 226, 227, 1, 0, 0, 0, 227, 228,
		3, 138, 69, 0, 228, 229, 5, 0, 0, 1, 229, 1, 1, 0, 0, 0, 230, 231, 5, 27,
		0, 0, 231, 235, 5, 78, 0, 0, 232, 234, 7, 0, 0, 0, 233, 232, 1, 0, 0, 0,
		234, 237, 1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236,
		3, 1, 0, 0, 0, 237, 235, 1, 0, 0, 0, 238, 239, 7, 1, 0, 0, 239, 5, 1, 0,
		0, 0, 240, 241, 5, 82, 0, 0, 241, 242, 3, 4, 2, 0, 242, 7, 1, 0, 0, 0,
		243, 244, 5, 83, 0, 0, 244, 245, 3, 12, 6, 0, 245, 9, 1, 0, 0, 0, 246,
		247, 5, 84, 0, 0, 247, 11, 1, 0, 0, 0, 248, 249, 5, 109, 0, 0, 249, 13,
		1, 0, 0, 0, 250, 251, 5, 88, 0, 0, 251, 252, 3, 22, 11, 0, 252, 253, 5,
		89, 0, 0, 253, 15, 1, 0, 0, 0, 254, 255, 5, 90, 0, 0, 255, 256, 3, 22,
		11, 0, 256, 257, 5, 89, 0, 0, 257, 17, 1, 0, 0, 0, 258, 259, 5, 92, 0,
		0, 259, 19, 1, 0, 0, 0, 260, 261, 5, 91, 0, 0, 261, 21, 1, 0, 0, 0, 262,
		264, 5, 85, 0, 0, 263, 262, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265,
		1, 0, 0, 0, 265, 266, 5, 79, 0, 0, 266, 267, 3, 22, 11, 0, 267, 268, 5,
		80, 0, 0, 268, 271, 1, 0, 0, 0, 269, 271, 3, 26, 13, 0, 270, 263, 1, 0,
		0, 0, 270, 269, 1, 0, 0, 0, 271, 23, 1, 0, 0, 0, 272, 274, 5, 79, 0, 0,
		273, 275, 5, 85, 0, 0, 274, 273, 1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275,
		276, 1, 0, 0, 0, 276, 277, 3, 24, 12, 0, 277, 278, 5, 80, 0, 0, 278, 288,
		1, 0, 0, 0, 279, 281, 5, 85, 0, 0, 280, 279, 1, 0, 0, 0, 280, 281, 1, 0,
		0, 0, 281, 282, 1, 0, 0, 0, 282, 288, 3, 28, 14, 0, 283, 284, 5, 79, 0,
		0, 284, 285, 3, 26, 13, 0, 285, 286, 5, 80, 0, 0, 286, 288, 1, 0, 0, 0,
		287, 272, 1, 0, 0, 0, 287, 280, 1, 0, 0, 0, 287, 283, 1, 0, 0, 0, 288,
		25, 1, 0, 0, 0, 289, 295, 3, 24, 12, 0, 290, 291, 3, 32, 16, 0, 291, 292,
		3, 24, 12, 0, 292, 294, 1, 0, 0, 0, 293, 290, 1, 0, 0, 0, 294, 297, 1,
		0, 0, 0, 295, 293, 1, 0, 0, 0, 295, 296, 1, 0, 0, 0, 296, 27, 1, 0, 0,
		0, 297, 295, 1, 0, 0, 0, 298, 316, 5, 102, 0, 0, 299, 316, 5, 101, 0, 0,
		300, 316, 5, 104, 0, 0, 301, 316, 5, 103, 0, 0, 302, 316, 5, 93, 0, 0,
		303, 316, 5, 94, 0, 0, 304, 316, 5, 95, 0, 0, 305, 316, 5, 96, 0, 0, 306,
		316, 5, 97, 0, 0, 307, 316, 5, 98, 0, 0, 308, 316, 5, 99, 0, 0, 309, 316,
		5, 100, 0, 0, 310, 316, 5, 105, 0, 0, 311, 316, 5, 106, 0, 0, 312, 316,
		5, 107, 0, 0, 313, 316, 5, 108, 0, 0, 314, 316, 3, 30, 15, 0, 315, 298,
		1, 0, 0, 0, 315, 299, 1, 0, 0, 0, 315, 300, 1, 0, 0, 0, 315, 301, 1, 0,
		0, 0, 315, 302, 1, 0, 0, 0, 315, 303, 1, 0, 0, 0, 315, 304, 1, 0, 0, 0,
		315, 305, 1, 0, 0, 0, 315, 306, 1, 0, 0, 0, 315, 307, 1, 0, 0, 0, 315,
		308, 1, 0, 0, 0, 315, 309, 1, 0, 0, 0, 315, 310, 1, 0, 0, 0, 315, 311,
		1, 0, 0, 0, 315, 312, 1, 0, 0, 0, 315, 313, 1, 0, 0, 0, 315, 314, 1, 0,
		0, 0, 316, 29, 1, 0, 0, 0, 317, 318, 5, 109, 0, 0, 318, 31, 1, 0, 0, 0,
		319, 320, 7, 2, 0, 0, 320, 33, 1, 0, 0, 0, 321, 329, 5, 27, 0, 0, 322,
		330, 3, 8, 4, 0, 323, 330, 3, 10, 5, 0, 324, 330, 3, 14, 7, 0, 325, 330,
		3, 16, 8, 0, 326, 330, 3, 18, 9, 0, 327, 330, 3, 20, 10, 0, 328, 330, 3,
		6, 3, 0, 329, 322, 1, 0, 0, 0, 329, 323, 1, 0, 0, 0, 329, 324, 1, 0, 0,
		0, 329, 325, 1, 0, 0, 0, 329, 326, 1, 0, 0, 0, 329, 327, 1, 0, 0, 0, 329,
		328, 1, 0, 0, 0, 330, 35, 1, 0, 0, 0, 331, 332, 7, 3, 0, 0, 332, 37, 1,
		0, 0, 0, 333, 334, 5, 23, 0, 0, 334, 335, 3, 36, 18, 0, 335, 39, 1, 0,
		0, 0, 336, 337, 7, 4, 0, 0, 337, 41, 1, 0, 0, 0, 338, 339, 5, 76, 0, 0,
		339, 43, 1, 0, 0, 0, 340, 341, 5, 23, 0, 0, 341, 343, 3, 40, 20, 0, 342,
		344, 3, 46, 23, 0, 343, 342, 1, 0, 0, 0, 343, 344, 1, 0, 0, 0, 344, 45,
		1, 0, 0, 0, 345, 354, 5, 6, 0, 0, 346, 351, 3, 48, 24, 0, 347, 348, 5,
		10, 0, 0, 348, 350, 3, 48, 24, 0, 349, 347, 1, 0, 0, 0, 350, 353, 1, 0,
		0, 0, 351, 349, 1, 0, 0, 0, 351, 352, 1, 0, 0, 0, 352, 355, 1, 0, 0, 0,
		353, 351, 1, 0, 0, 0, 354, 346, 1, 0, 0, 0, 354, 355, 1, 0, 0, 0, 355,
		356, 1, 0, 0, 0, 356, 357, 5, 7, 0, 0, 357, 47, 1, 0, 0, 0, 358, 361, 3,
		42, 21, 0, 359, 360, 5, 11, 0, 0, 360, 362, 3, 150, 75, 0, 361, 359, 1,
		0, 0, 0, 361, 362, 1, 0, 0, 0, 362, 365, 1, 0, 0, 0, 363, 365, 3, 150,
		75, 0, 364, 358, 1, 0, 0, 0, 364, 363, 1, 0, 0, 0, 365, 49, 1, 0, 0, 0,
		366, 367, 5, 76, 0, 0, 367, 51, 1, 0, 0, 0, 368, 370, 3, 54, 27, 0, 369,
		368, 1, 0, 0, 0, 370, 371, 1, 0, 0, 0, 371, 369, 1, 0, 0, 0, 371, 372,
		1, 0, 0, 0, 372, 53, 1, 0, 0, 0, 373, 377, 3, 34, 17, 0, 374, 377, 3, 38,
		19, 0, 375, 377, 3, 44, 22, 0, 376, 373, 1, 0, 0, 0, 376, 374, 1, 0, 0,
		0, 376, 375, 1, 0, 0, 0, 377, 380, 1, 0, 0, 0, 378, 376, 1, 0, 0, 0, 378,
		379, 1, 0, 0, 0, 379, 381, 1, 0, 0, 0, 380, 378, 1, 0, 0, 0, 381, 382,
		5, 65, 0, 0, 382, 384, 3, 56, 28, 0, 383, 385, 5, 9, 0, 0, 384, 383, 1,
		0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 55, 1, 0, 0, 0, 386, 391, 3, 58, 29,
		0, 387, 388, 5, 10, 0, 0, 388, 390, 3, 58, 29, 0, 389, 387, 1, 0, 0, 0,
		390, 393, 1, 0, 0, 0, 391, 389, 1, 0, 0, 0, 391, 392, 1, 0, 0, 0, 392,
		57, 1, 0, 0, 0, 393, 391, 1, 0, 0, 0, 394, 396, 3, 50, 25, 0, 395, 397,
		5, 45, 0, 0, 396, 395, 1, 0, 0, 0, 396, 397, 1, 0, 0, 0, 397, 59, 1, 0,
		0, 0, 398, 400, 3, 62, 31, 0, 399, 398, 1, 0, 0, 0, 400, 401, 1, 0, 0,
		0, 401, 399, 1, 0, 0, 0, 401, 402, 1, 0, 0, 0, 402, 61, 1, 0, 0, 0, 403,
		407, 3, 34, 17, 0, 404, 407, 3, 38, 19, 0, 405, 407, 3, 44, 22, 0, 406,
		403, 1, 0, 0, 0, 406, 404, 1, 0, 0, 0, 406, 405, 1, 0, 0, 0, 407, 410,
		1, 0, 0, 0, 408, 406, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 411, 1, 0,
		0, 0, 410, 408, 1, 0, 0, 0, 411, 412, 5, 65, 0, 0, 412, 414, 3, 64, 32,
		0, 413, 415, 5, 9, 0, 0, 414, 413, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0, 415,
		63, 1, 0, 0, 0, 416, 421, 3, 66, 33, 0, 417, 418, 5, 10, 0, 0, 418, 420,
		3, 66, 33, 0, 419, 417, 1, 0, 0, 0, 420, 423, 1, 0, 0, 0, 421, 419, 1,
		0, 0, 0, 421, 422, 1, 0, 0, 0, 422, 65, 1, 0, 0, 0, 423, 421, 1, 0, 0,
		0, 424, 425, 3, 50, 25, 0, 425, 67, 1, 0, 0, 0, 426, 427, 5, 76, 0, 0,
		427, 69, 1, 0, 0, 0, 428, 430, 3, 72, 36, 0, 429, 428, 1, 0, 0, 0, 430,
		431, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 432, 1, 0, 0, 0, 432, 71, 1,
		0, 0, 0, 433, 436, 3, 74, 37, 0, 434, 436, 3, 76, 38, 0, 435, 433, 1, 0,
		0, 0, 435, 434, 1, 0, 0, 0, 436, 73, 1, 0, 0, 0, 437, 438, 3, 78, 39, 0,
		438, 439, 3, 82, 41, 0, 439, 440, 5, 43, 0, 0, 440, 75, 1, 0, 0, 0, 441,
		442, 3, 80, 40, 0, 442, 443, 3, 82, 41, 0, 443, 444, 5, 44, 0, 0, 444,
		77, 1, 0, 0, 0, 445, 449, 3, 34, 17, 0, 446, 449, 3, 38, 19, 0, 447, 449,
		3, 44, 22, 0, 448, 445, 1, 0, 0, 0, 448, 446, 1, 0, 0, 0, 448, 447, 1,
		0, 0, 0, 449, 452, 1, 0, 0, 0, 450, 448, 1, 0, 0, 0, 450, 451, 1, 0, 0,
		0, 451, 454, 1, 0, 0, 0, 452, 450, 1, 0, 0, 0, 453, 455, 5, 75, 0, 0, 454,
		453, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 456, 1, 0, 0, 0, 456, 457,
		5, 41, 0, 0, 457, 458, 3, 68, 34, 0, 458, 460, 5, 6, 0, 0, 459, 461, 3,
		144, 72, 0, 460, 459, 1, 0, 0, 0, 460, 461, 1, 0, 0, 0, 461, 462, 1, 0,
		0, 0, 462, 464, 5, 7, 0, 0, 463, 465, 5, 45, 0, 0, 464, 463, 1, 0, 0, 0,
		464, 465, 1, 0, 0, 0, 465, 79, 1, 0, 0, 0, 466, 470, 3, 34, 17, 0, 467,
		470, 3, 38, 19, 0, 468, 470, 3, 44, 22, 0, 469, 466, 1, 0, 0, 0, 469, 467,
		1, 0, 0, 0, 469, 468, 1, 0, 0, 0, 470, 473, 1, 0, 0, 0, 471, 469, 1, 0,
		0, 0, 471, 472, 1, 0, 0, 0, 472, 475, 1, 0, 0, 0, 473, 471, 1, 0, 0, 0,
		474, 476, 5, 75, 0, 0, 475, 474, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476,
		477, 1, 0, 0, 0, 477, 478, 5, 42, 0, 0, 478, 479, 3, 68, 34, 0, 479, 481,
		5, 6, 0, 0, 480, 482, 3, 144, 72, 0, 481, 480, 1, 0, 0, 0, 481, 482, 1,
		0, 0, 0, 482, 483, 1, 0, 0, 0, 483, 485, 5, 7, 0, 0, 484, 486, 5, 45, 0,
		0, 485, 484, 1, 0, 0, 0, 485, 486, 1, 0, 0, 0, 486, 81, 1, 0, 0, 0, 487,
		489, 3, 60, 30, 0, 488, 487, 1, 0, 0, 0, 488, 489, 1, 0, 0, 0, 489, 490,
		1, 0, 0, 0, 490, 491, 3, 140, 70, 0, 491, 83, 1, 0, 0, 0, 492, 493, 5,
		63, 0, 0, 493, 85, 1, 0, 0, 0, 494, 495, 5, 71, 0, 0, 495, 87, 1, 0, 0,
		0, 496, 501, 5, 64, 0, 0, 497, 499, 3, 164, 82, 0, 498, 497, 1, 0, 0, 0,
		498, 499, 1, 0, 0, 0, 499, 502, 1, 0, 0, 0, 500, 502, 3, 200, 100, 0, 501,
		498, 1, 0, 0, 0, 501, 500, 1, 0, 0, 0, 502, 89, 1, 0, 0, 0, 503, 507, 3,
		92, 46, 0, 504, 506, 3, 94, 47, 0, 505, 504, 1, 0, 0, 0, 506, 509, 1, 0,
		0, 0, 507, 505, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 511, 1, 0, 0, 0,
		509, 507, 1, 0, 0, 0, 510, 512, 3, 96, 48, 0, 511, 510, 1, 0, 0, 0, 511,
		512, 1, 0, 0, 0, 512, 513, 1, 0, 0, 0, 513, 514, 5, 47, 0, 0, 514, 91,
		1, 0, 0, 0, 515, 516, 5, 49, 0, 0, 516, 517, 3, 164, 82, 0, 517, 518, 5,
		52, 0, 0, 518, 519, 3, 140, 70, 0, 519, 93, 1, 0, 0, 0, 520, 521, 5, 50,
		0, 0, 521, 522, 3, 164, 82, 0, 522, 523, 5, 52, 0, 0, 523, 524, 3, 140,
		70, 0, 524, 95, 1, 0, 0, 0, 525, 526, 5, 51, 0, 0, 526, 527, 3, 140, 70,
		0, 527, 97, 1, 0, 0, 0, 528, 529, 5, 53, 0, 0, 529, 530, 3, 164, 82, 0,
		530, 531, 5, 54, 0, 0, 531, 532, 3, 140, 70, 0, 532, 533, 5, 48, 0, 0,
		533, 99, 1, 0, 0, 0, 534, 535, 5, 55, 0, 0, 535, 536, 5, 76, 0, 0, 536,
		537, 5, 11, 0, 0, 537, 538, 3, 164, 82, 0, 538, 539, 5, 56, 0, 0, 539,
		540, 3, 164, 82, 0, 540, 541, 5, 54, 0, 0, 541, 542, 3, 140, 70, 0, 542,
		543, 5, 48, 0, 0, 543, 101, 1, 0, 0, 0, 544, 545, 5, 55, 0, 0, 545, 546,
		5, 57, 0, 0, 546, 547, 5, 76, 0, 0, 547, 548, 5, 58, 0, 0, 548, 549, 3,
		164, 82, 0, 549, 550, 5, 54, 0, 0, 550, 551, 3, 140, 70, 0, 551, 552, 5,
		48, 0, 0, 552, 103, 1, 0, 0, 0, 553, 554, 5, 59, 0, 0, 554, 555, 3, 120,
		60, 0, 555, 556, 5, 60, 0, 0, 556, 557, 3, 122, 61, 0, 557, 558, 5, 61,
		0, 0, 558, 105, 1, 0, 0, 0, 559, 561, 5, 62, 0, 0, 560, 562, 3, 164, 82,
		0, 561, 560, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 107, 1, 0, 0, 0, 563,
		566, 5, 72, 0, 0, 564, 567, 3, 200, 100, 0, 565, 567, 3, 160, 80, 0, 566,
		564, 1, 0, 0, 0, 566, 565, 1, 0, 0, 0, 567, 109, 1, 0, 0, 0, 568, 571,
		5, 76, 0, 0, 569, 571, 3, 182, 91, 0, 570, 568, 1, 0, 0, 0, 570, 569, 1,
		0, 0, 0, 571, 575, 1, 0, 0, 0, 572, 574, 3, 188, 94, 0, 573, 572, 1, 0,
		0, 0, 574, 577, 1, 0, 0, 0, 575, 573, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0,
		576, 578, 1, 0, 0, 0, 577, 575, 1, 0, 0, 0, 578, 581, 3, 194, 97, 0, 579,
		581, 3, 182, 91, 0, 580, 570, 1, 0, 0, 0, 580, 579, 1, 0, 0, 0, 581, 111,
		1, 0, 0, 0, 582, 583, 3, 134, 67, 0, 583, 113, 1, 0, 0, 0, 584, 585, 5,
		76, 0, 0, 585, 115, 1, 0, 0, 0, 586, 587, 5, 29, 0, 0, 587, 588, 3, 114,
		57, 0, 588, 589, 5, 8, 0, 0, 589, 117, 1, 0, 0, 0, 590, 591, 5, 70, 0,
		0, 591, 592, 5, 29, 0, 0, 592, 593, 3, 114, 57, 0, 593, 119, 1, 0, 0, 0,
		594, 595, 3, 140, 70, 0, 595, 121, 1, 0, 0, 0, 596, 597, 3, 140, 70, 0,
		597, 123, 1, 0, 0, 0, 598, 599, 3, 164, 82, 0, 599, 125, 1, 0, 0, 0, 600,
		601, 3, 164, 82, 0, 601, 127, 1, 0, 0, 0, 602, 603, 5, 73, 0, 0, 603, 604,
		3, 124, 62, 0, 604, 605, 5, 10, 0, 0, 605, 606, 3, 126, 63, 0, 606, 129,
		1, 0, 0, 0, 607, 608, 5, 74, 0, 0, 608, 609, 3, 124, 62, 0, 609, 610, 5,
		10, 0, 0, 610, 611, 3, 126, 63, 0, 611, 131, 1, 0, 0, 0, 612, 613, 5, 22,
		0, 0, 613, 614, 5, 6, 0, 0, 614, 615, 3, 164, 82, 0, 615, 616, 5, 10, 0,
		0, 616, 617, 3, 164, 82, 0, 617, 618, 5, 10, 0, 0, 618, 619, 3, 164, 82,
		0, 619, 620, 5, 7, 0, 0, 620, 133, 1, 0, 0, 0, 621, 622, 5, 125, 0, 0,
		622, 623, 3, 164, 82, 0, 623, 135, 1, 0, 0, 0, 624, 625, 3, 140, 70, 0,
		625, 137, 1, 0, 0, 0, 626, 627, 3, 140, 70, 0, 627, 139, 1, 0, 0, 0, 628,
		631, 3, 156, 78, 0, 629, 631, 3, 34, 17, 0, 630, 628, 1, 0, 0, 0, 630,
		629, 1, 0, 0, 0, 631, 634, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 632, 633,
		1, 0, 0, 0, 633, 141, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 635, 636, 7, 5,
		0, 0, 636, 143, 1, 0, 0, 0, 637, 642, 3, 146, 73, 0, 638, 639, 5, 10, 0,
		0, 639, 641, 3, 146, 73, 0, 640, 638, 1, 0, 0, 0, 641, 644, 1, 0, 0, 0,
		642, 640, 1, 0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 145, 1, 0, 0, 0, 644,
		642, 1, 0, 0, 0, 645, 647, 3, 44, 22, 0, 646, 645, 1, 0, 0, 0, 647, 650,
		1, 0, 0, 0, 648, 646, 1, 0, 0, 0, 648, 649, 1, 0, 0, 0, 649, 652, 1, 0,
		0, 0, 650, 648, 1, 0, 0, 0, 651, 653, 5, 46, 0, 0, 652, 651, 1, 0, 0, 0,
		652, 653, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0, 654, 657, 5, 76, 0, 0, 655,
		656, 5, 11, 0, 0, 656, 658, 3, 148, 74, 0, 657, 655, 1, 0, 0, 0, 657, 658,
		1, 0, 0, 0, 658, 147, 1, 0, 0, 0, 659, 660, 3, 150, 75, 0, 660, 149, 1,
		0, 0, 0, 661, 663, 7, 6, 0, 0, 662, 661, 1, 0, 0, 0, 662, 663, 1, 0, 0,
		0, 663, 664, 1, 0, 0, 0, 664, 672, 3, 142, 71, 0, 665, 672, 3, 154, 77,
		0, 666, 672, 5, 30, 0, 0, 667, 672, 5, 31, 0, 0, 668, 672, 5, 32, 0, 0,
		669, 672, 5, 33, 0, 0, 670, 672, 5, 35, 0, 0, 671, 662, 1, 0, 0, 0, 671,
		665, 1, 0, 0, 0, 671, 666, 1, 0, 0, 0, 671, 667, 1, 0, 0, 0, 671, 668,
		1, 0, 0, 0, 671, 669, 1, 0, 0, 0, 671, 670, 1, 0, 0, 0, 672, 151, 1, 0,
		0, 0, 673, 679, 5, 38, 0, 0, 674, 678, 5, 40, 0, 0, 675, 678, 5, 28, 0,
		0, 676, 678, 3, 34, 17, 0, 677, 674, 1, 0, 0, 0, 677, 675, 1, 0, 0, 0,
		677, 676, 1, 0, 0, 0, 678, 681, 1, 0, 0, 0, 679, 677, 1, 0, 0, 0, 679,
		680, 1, 0, 0, 0, 680, 682, 1, 0, 0, 0, 681, 679, 1, 0, 0, 0, 682, 683,
		5, 39, 0, 0, 683, 153, 1, 0, 0, 0, 684, 687, 5, 37, 0, 0, 685, 687, 3,
		152, 76, 0, 686, 684, 1, 0, 0, 0, 686, 685, 1, 0, 0, 0, 687, 688, 1, 0,
		0, 0, 688, 686, 1, 0, 0, 0, 688, 689, 1, 0, 0, 0, 689, 155, 1, 0, 0, 0,
		690, 696, 3, 116, 58, 0, 691, 697, 3, 110, 55, 0, 692, 697, 3, 112, 56,
		0, 693, 697, 3, 202, 101, 0, 694, 697, 3, 158, 79, 0, 695, 697, 3, 34,
		17, 0, 696, 691, 1, 0, 0, 0, 696, 692, 1, 0, 0, 0, 696, 693, 1, 0, 0, 0,
		696, 694, 1, 0, 0, 0, 696, 695, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697,
		706, 1, 0, 0, 0, 698, 704, 3, 110, 55, 0, 699, 704, 3, 112, 56, 0, 700,
		704, 3, 202, 101, 0, 701, 704, 3, 158, 79, 0, 702, 704, 3, 34, 17, 0, 703,
		698, 1, 0, 0, 0, 703, 699, 1, 0, 0, 0, 703, 700, 1, 0, 0, 0, 703, 701,
		1, 0, 0, 0, 703, 702, 1, 0, 0, 0, 704, 706, 1, 0, 0, 0, 705, 690, 1, 0,
		0, 0, 705, 703, 1, 0, 0, 0, 706, 708, 1, 0, 0, 0, 707, 709, 5, 9, 0, 0,
		708, 707, 1, 0, 0, 0, 708, 709, 1, 0, 0, 0, 709, 712, 1, 0, 0, 0, 710,
		712, 5, 9, 0, 0, 711, 705, 1, 0, 0, 0, 711, 710, 1, 0, 0, 0, 712, 157,
		1, 0, 0, 0, 713, 717, 3, 192, 96, 0, 714, 716, 3, 34, 17, 0, 715, 714,
		1, 0, 0, 0, 716, 719, 1, 0, 0, 0, 717, 715, 1, 0, 0, 0, 717, 718, 1, 0,
		0, 0, 718, 720, 1, 0, 0, 0, 719, 717, 1, 0, 0, 0, 720, 724, 5, 11, 0, 0,
		721, 723, 3, 34, 17, 0, 722, 721, 1, 0, 0, 0, 723, 726, 1, 0, 0, 0, 724,
		722, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 727, 1, 0, 0, 0, 726, 724,
		1, 0, 0, 0, 727, 728, 3, 164, 82, 0, 728, 159, 1, 0, 0, 0, 729, 734, 3,
		162, 81, 0, 730, 731, 5, 10, 0, 0, 731, 733, 3, 162, 81, 0, 732, 730, 1,
		0, 0, 0, 733, 736, 1, 0, 0, 0, 734, 732, 1, 0, 0, 0, 734, 735, 1, 0, 0,
		0, 735, 161, 1, 0, 0, 0, 736, 734, 1, 0, 0, 0, 737, 739, 3, 164, 82, 0,
		738, 737, 1, 0, 0, 0, 738, 739, 1, 0, 0, 0, 739, 163, 1, 0, 0, 0, 740,
		763, 3, 174, 87, 0, 741, 743, 3, 34, 17, 0, 742, 741, 1, 0, 0, 0, 743,
		746, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 744, 745, 1, 0, 0, 0, 745, 747,
		1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 747, 751, 3, 166, 83, 0, 748, 750, 3,
		34, 17, 0, 749, 748, 1, 0, 0, 0, 750, 753, 1, 0, 0, 0, 751, 749, 1, 0,
		0, 0, 751, 752, 1, 0, 0, 0, 752, 754, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0,
		754, 758, 3, 174, 87, 0, 755, 757, 3, 34, 17, 0, 756, 755, 1, 0, 0, 0,
		757, 760, 1, 0, 0, 0, 758, 756, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759,
		762, 1, 0, 0, 0, 760, 758, 1, 0, 0, 0, 761, 744, 1, 0, 0, 0, 762, 765,
		1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 165, 1, 0,
		0, 0, 765, 763, 1, 0, 0, 0, 766, 774, 5, 12, 0, 0, 767, 774, 5, 13, 0,
		0, 768, 774, 5, 19, 0, 0, 769, 774, 5, 20, 0, 0, 770, 774, 5, 21, 0, 0,
		771, 774, 3, 170, 85, 0, 772, 774, 3, 168, 84, 0, 773, 766, 1, 0, 0, 0,
		773, 767, 1, 0, 0, 0, 773, 768, 1, 0, 0, 0, 773, 769, 1, 0, 0, 0, 773,
		770, 1, 0, 0, 0, 773, 771, 1, 0, 0, 0, 773, 772, 1, 0, 0, 0, 774, 167,
		1, 0, 0, 0, 775, 776, 7, 7, 0, 0, 776, 169, 1, 0, 0, 0, 777, 778, 7, 8,
		0, 0, 778, 171, 1, 0, 0, 0, 779, 780, 7, 9, 0, 0, 780, 173, 1, 0, 0, 0,
		781, 783, 3, 172, 86, 0, 782, 781, 1, 0, 0, 0, 782, 783, 1, 0, 0, 0, 783,
		801, 1, 0, 0, 0, 784, 802, 3, 150, 75, 0, 785, 802, 3, 186, 93, 0, 786,
		787, 5, 6, 0, 0, 787, 788, 3, 164, 82, 0, 788, 789, 5, 7, 0, 0, 789, 793,
		1, 0, 0, 0, 790, 792, 3, 188, 94, 0, 791, 790, 1, 0, 0, 0, 792, 795, 1,
		0, 0, 0, 793, 791, 1, 0, 0, 0, 793, 794, 1, 0, 0, 0, 794, 802, 1, 0, 0,
		0, 795, 793, 1, 0, 0, 0, 796, 799, 5, 76, 0, 0, 797, 799, 3, 182, 91, 0,
		798, 796, 1, 0, 0, 0, 798, 797, 1, 0, 0, 0, 799, 802, 1, 0, 0, 0, 800,
		802, 3, 134, 67, 0, 801, 784, 1, 0, 0, 0, 801, 785, 1, 0, 0, 0, 801, 786,
		1, 0, 0, 0, 801, 798, 1, 0, 0, 0, 801, 800, 1, 0, 0, 0, 802, 175, 1, 0,
		0, 0, 803, 804, 5, 69, 0, 0, 804, 806, 3, 178, 89, 0, 805, 807, 3, 200,
		100, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 811, 1, 0, 0,
		0, 808, 809, 5, 69, 0, 0, 809, 811, 3, 200, 100, 0, 810, 803, 1, 0, 0,
		0, 810, 808, 1, 0, 0, 0, 811, 177, 1, 0, 0, 0, 812, 813, 5, 76, 0, 0, 813,
		179, 1, 0, 0, 0, 814, 815, 3, 184, 92, 0, 815, 816, 3, 200, 100, 0, 816,
		181, 1, 0, 0, 0, 817, 818, 3, 184, 92, 0, 818, 819, 3, 200, 100, 0, 819,
		183, 1, 0, 0, 0, 820, 821, 5, 76, 0, 0, 821, 185, 1, 0, 0, 0, 822, 827,
		5, 76, 0, 0, 823, 827, 3, 176, 88, 0, 824, 827, 3, 132, 66, 0, 825, 827,
		3, 182, 91, 0, 826, 822, 1, 0, 0, 0, 826, 823, 1, 0, 0, 0, 826, 824, 1,
		0, 0, 0, 826, 825, 1, 0, 0, 0, 827, 831, 1, 0, 0, 0, 828, 830, 3, 188,
		94, 0, 829, 828, 1, 0, 0, 0, 830, 833, 1, 0, 0, 0, 831, 829, 1, 0, 0, 0,
		831, 832, 1, 0, 0, 0, 832, 187, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0, 834,
		838, 3, 198, 99, 0, 835, 838, 3, 196, 98, 0, 836, 838, 3, 194, 97, 0, 837,
		834, 1, 0, 0, 0, 837, 835, 1, 0, 0, 0, 837, 836, 1, 0, 0, 0, 838, 189,
		1, 0, 0, 0, 839, 841, 3, 188, 94, 0, 840, 839, 1, 0, 0, 0, 841, 844, 1,
		0, 0, 0, 842, 840, 1, 0, 0, 0, 842, 843, 1, 0, 0, 0, 843, 847, 1, 0, 0,
		0, 844, 842, 1, 0, 0, 0, 845, 848, 3, 198, 99, 0, 846, 848, 3, 196, 98,
		0, 847, 845, 1, 0, 0, 0, 847, 846, 1, 0, 0, 0, 848, 191, 1, 0, 0, 0, 849,
		852, 5, 76, 0, 0, 850, 852, 3, 182, 91, 0, 851, 849, 1, 0, 0, 0, 851, 850,
		1, 0, 0, 0, 852, 854, 1, 0, 0, 0, 853, 855, 3, 190, 95, 0, 854, 853, 1,
		0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 193, 1, 0, 0, 0, 856, 857, 5, 3, 0,
		0, 857, 858, 3, 180, 90, 0, 858, 195, 1, 0, 0, 0, 859, 860, 5, 4, 0, 0,
		860, 861, 3, 164, 82, 0, 861, 862, 5, 5, 0, 0, 862, 197, 1, 0, 0, 0, 863,
		864, 5, 3, 0, 0, 864, 865, 5, 76, 0, 0, 865, 199, 1, 0, 0, 0, 866, 867,
		5, 6, 0, 0, 867, 868, 3, 160, 80, 0, 868, 869, 5, 7, 0, 0, 869, 201, 1,
		0, 0, 0, 870, 884, 3, 90, 45, 0, 871, 884, 3, 98, 49, 0, 872, 884, 3, 100,
		50, 0, 873, 884, 3, 102, 51, 0, 874, 884, 3, 104, 52, 0, 875, 884, 3, 106,
		53, 0, 876, 884, 3, 84, 42, 0, 877, 884, 3, 86, 43, 0, 878, 884, 3, 88,
		44, 0, 879, 884, 3, 108, 54, 0, 880, 884, 3, 118, 59, 0, 881, 884, 3, 128,
		64, 0, 882, 884, 3, 130, 65, 0, 883, 870, 1, 0, 0, 0, 883, 871, 1, 0, 0,
		0, 883, 872, 1, 0, 0, 0, 883, 873, 1, 0, 0, 0, 883, 874, 1, 0, 0, 0, 883,
		875, 1, 0, 0, 0, 883, 876, 1, 0, 0, 0, 883, 877, 1, 0, 0, 0, 883, 878,
		1, 0, 0, 0, 883, 879, 1, 0, 0, 0, 883, 880, 1, 0, 0, 0, 883, 881, 1, 0,
		0, 0, 883, 882, 1, 0, 0, 0, 884, 203, 1, 0, 0, 0, 92, 205, 210, 214, 219,
		225, 235, 263, 270, 274, 280, 287, 295, 315, 329, 343, 351, 354, 361, 364,
		371, 376, 378, 384, 391, 396, 401, 406, 408, 414, 421, 431, 435, 448, 450,
		454, 460, 464, 469, 471, 475, 481, 485, 488, 498, 501, 507, 511, 561, 566,
		570, 575, 580, 630, 632, 642, 648, 652, 657, 662, 671, 677, 679, 686, 688,
		696, 703, 705, 708, 711, 717, 724, 734, 738, 744, 751, 758, 763, 773, 782,
		793, 798, 801, 806, 810, 826, 831, 837, 842, 847, 851, 854, 883,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// BSLParserInit initializes any static state used to implement BSLParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewBSLParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func BSLParserInit() {
	staticData := &bslparserParserStaticData
	staticData.once.Do(bslparserParserInit)
}

// NewBSLParser produces a new parser instance for the optional input antlr.TokenStream.
func NewBSLParser(input antlr.TokenStream) *BSLParser {
	BSLParserInit()
	this := new(BSLParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &bslparserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// BSLParser tokens.
const (
	BSLParserEOF                                           = antlr.TokenEOF
	BSLParserLINE_COMMENT                                  = 1
	BSLParserWHITE_SPACE                                   = 2
	BSLParserDOT                                           = 3
	BSLParserLBRACK                                        = 4
	BSLParserRBRACK                                        = 5
	BSLParserLPAREN                                        = 6
	BSLParserRPAREN                                        = 7
	BSLParserCOLON                                         = 8
	BSLParserSEMICOLON                                     = 9
	BSLParserCOMMA                                         = 10
	BSLParserASSIGN                                        = 11
	BSLParserPLUS                                          = 12
	BSLParserMINUS                                         = 13
	BSLParserLESS_OR_EQUAL                                 = 14
	BSLParserNOT_EQUAL                                     = 15
	BSLParserLESS                                          = 16
	BSLParserGREATER_OR_EQUAL                              = 17
	BSLParserGREATER                                       = 18
	BSLParserMUL                                           = 19
	BSLParserQUOTIENT                                      = 20
	BSLParserMODULO                                        = 21
	BSLParserQUESTION                                      = 22
	BSLParserAMPERSAND                                     = 23
	BSLParserPREPROC_DELETE                                = 24
	BSLParserPREPROC_INSERT                                = 25
	BSLParserPREPROC_ENDINSERT                             = 26
	BSLParserHASH                                          = 27
	BSLParserBAR                                           = 28
	BSLParserTILDA                                         = 29
	BSLParserTRUE                                          = 30
	BSLParserFALSE                                         = 31
	BSLParserUNDEFINED                                     = 32
	BSLParserNULL                                          = 33
	BSLParserDECIMAL                                       = 34
	BSLParserDATETIME                                      = 35
	BSLParserFLOAT                                         = 36
	BSLParserSTRING                                        = 37
	BSLParserSTRINGSTART                                   = 38
	BSLParserSTRINGTAIL                                    = 39
	BSLParserSTRINGPART                                    = 40
	BSLParserPROCEDURE_KEYWORD                             = 41
	BSLParserFUNCTION_KEYWORD                              = 42
	BSLParserENDPROCEDURE_KEYWORD                          = 43
	BSLParserENDFUNCTION_KEYWORD                           = 44
	BSLParserEXPORT_KEYWORD                                = 45
	BSLParserVAL_KEYWORD                                   = 46
	BSLParserENDIF_KEYWORD                                 = 47
	BSLParserENDDO_KEYWORD                                 = 48
	BSLParserIF_KEYWORD                                    = 49
	BSLParserELSIF_KEYWORD                                 = 50
	BSLParserELSE_KEYWORD                                  = 51
	BSLParserTHEN_KEYWORD                                  = 52
	BSLParserWHILE_KEYWORD                                 = 53
	BSLParserDO_KEYWORD                                    = 54
	BSLParserFOR_KEYWORD                                   = 55
	BSLParserTO_KEYWORD                                    = 56
	BSLParserEACH_KEYWORD                                  = 57
	BSLParserIN_KEYWORD                                    = 58
	BSLParserTRY_KEYWORD                                   = 59
	BSLParserEXCEPT_KEYWORD                                = 60
	BSLParserENDTRY_KEYWORD                                = 61
	BSLParserRETURN_KEYWORD                                = 62
	BSLParserCONTINUE_KEYWORD                              = 63
	BSLParserRAISE_KEYWORD                                 = 64
	BSLParserVAR_KEYWORD                                   = 65
	BSLParserNOT_KEYWORD                                   = 66
	BSLParserOR_KEYWORD                                    = 67
	BSLParserAND_KEYWORD                                   = 68
	BSLParserNEW_KEYWORD                                   = 69
	BSLParserGOTO_KEYWORD                                  = 70
	BSLParserBREAK_KEYWORD                                 = 71
	BSLParserEXECUTE_KEYWORD                               = 72
	BSLParserADDHANDLER_KEYWORD                            = 73
	BSLParserREMOVEHANDLER_KEYWORD                         = 74
	BSLParserASYNC_KEYWORD                                 = 75
	BSLParserIDENTIFIER                                    = 76
	BSLParserUNKNOWN                                       = 77
	BSLParserPREPROC_EXCLAMATION_MARK                      = 78
	BSLParserPREPROC_LPAREN                                = 79
	BSLParserPREPROC_RPAREN                                = 80
	BSLParserPREPROC_STRING                                = 81
	BSLParserPREPROC_USE_KEYWORD                           = 82
	BSLParserPREPROC_REGION                                = 83
	BSLParserPREPROC_END_REGION                            = 84
	BSLParserPREPROC_NOT_KEYWORD                           = 85
	BSLParserPREPROC_OR_KEYWORD                            = 86
	BSLParserPREPROC_AND_KEYWORD                           = 87
	BSLParserPREPROC_IF_KEYWORD                            = 88
	BSLParserPREPROC_THEN_KEYWORD                          = 89
	BSLParserPREPROC_ELSIF_KEYWORD                         = 90
	BSLParserPREPROC_ENDIF_KEYWORD                         = 91
	BSLParserPREPROC_ELSE_KEYWORD                          = 92
	BSLParserPREPROC_MOBILEAPPCLIENT_SYMBOL                = 93
	BSLParserPREPROC_MOBILEAPPSERVER_SYMBOL                = 94
	BSLParserPREPROC_MOBILECLIENT_SYMBOL                   = 95
	BSLParserPREPROC_THICKCLIENTORDINARYAPPLICATION_SYMBOL = 96
	BSLParserPREPROC_THICKCLIENTMANAGEDAPPLICATION_SYMBOL  = 97
	BSLParserPREPROC_EXTERNALCONNECTION_SYMBOL             = 98
	BSLParserPREPROC_THINCLIENT_SYMBOL                     = 99
	BSLParserPREPROC_WEBCLIENT_SYMBOL                      = 100
	BSLParserPREPROC_ATCLIENT_SYMBOL                       = 101
	BSLParserPREPROC_CLIENT_SYMBOL                         = 102
	BSLParserPREPROC_ATSERVER_SYMBOL                       = 103
	BSLParserPREPROC_SERVER_SYMBOL                         = 104
	BSLParserPREPROC_MOBILE_STANDALONE_SERVER              = 105
	BSLParserPREPROC_LINUX                                 = 106
	BSLParserPREPROC_WINDOWS                               = 107
	BSLParserPREPROC_MACOS                                 = 108
	BSLParserPREPROC_IDENTIFIER                            = 109
	BSLParserPREPROC_NEWLINE                               = 110
	BSLParserPREPROC_ANY                                   = 111
	BSLParserANNOTATION_ATSERVERNOCONTEXT_SYMBOL           = 112
	BSLParserANNOTATION_ATCLIENTATSERVERNOCONTEXT_SYMBOL   = 113
	BSLParserANNOTATION_ATCLIENTATSERVER_SYMBOL            = 114
	BSLParserANNOTATION_ATCLIENT_SYMBOL                    = 115
	BSLParserANNOTATION_ATSERVER_SYMBOL                    = 116
	BSLParserANNOTATION_BEFORE_SYMBOL                      = 117
	BSLParserANNOTATION_AFTER_SYMBOL                       = 118
	BSLParserANNOTATION_AROUND_SYMBOL                      = 119
	BSLParserANNOTATION_CHANGEANDVALIDATE_SYMBOL           = 120
	BSLParserANNOTATION_CUSTOM_SYMBOL                      = 121
	BSLParserANNOTATION_UNKNOWN                            = 122
	BSLParserPREPROC_ENDDELETE                             = 123
	BSLParserPREPROC_DELETE_ANY                            = 124
	BSLParserAWAIT_KEYWORD                                 = 125
)

// BSLParser rules.
const (
	BSLParserRULE_file                      = 0
	BSLParserRULE_shebang                   = 1
	BSLParserRULE_usedLib                   = 2
	BSLParserRULE_use                       = 3
	BSLParserRULE_regionStart               = 4
	BSLParserRULE_regionEnd                 = 5
	BSLParserRULE_regionName                = 6
	BSLParserRULE_preproc_if                = 7
	BSLParserRULE_preproc_elsif             = 8
	BSLParserRULE_preproc_else              = 9
	BSLParserRULE_preproc_endif             = 10
	BSLParserRULE_preproc_expression        = 11
	BSLParserRULE_preproc_logicalOperand    = 12
	BSLParserRULE_preproc_logicalExpression = 13
	BSLParserRULE_preproc_symbol            = 14
	BSLParserRULE_preproc_unknownSymbol     = 15
	BSLParserRULE_preproc_boolOperation     = 16
	BSLParserRULE_preprocessor              = 17
	BSLParserRULE_compilerDirectiveSymbol   = 18
	BSLParserRULE_compilerDirective         = 19
	BSLParserRULE_annotationName            = 20
	BSLParserRULE_annotationParamName       = 21
	BSLParserRULE_annotation                = 22
	BSLParserRULE_annotationParams          = 23
	BSLParserRULE_annotationParam           = 24
	BSLParserRULE_var_name                  = 25
	BSLParserRULE_moduleVars                = 26
	BSLParserRULE_moduleVar                 = 27
	BSLParserRULE_moduleVarsList            = 28
	BSLParserRULE_moduleVarDeclaration      = 29
	BSLParserRULE_subVars                   = 30
	BSLParserRULE_subVar                    = 31
	BSLParserRULE_subVarsList               = 32
	BSLParserRULE_subVarDeclaration         = 33
	BSLParserRULE_subName                   = 34
	BSLParserRULE_subs                      = 35
	BSLParserRULE_sub                       = 36
	BSLParserRULE_procedure                 = 37
	BSLParserRULE_function                  = 38
	BSLParserRULE_procDeclaration           = 39
	BSLParserRULE_funcDeclaration           = 40
	BSLParserRULE_subCodeBlock              = 41
	BSLParserRULE_continueStatement         = 42
	BSLParserRULE_breakStatement            = 43
	BSLParserRULE_raiseStatement            = 44
	BSLParserRULE_ifStatement               = 45
	BSLParserRULE_ifBranch                  = 46
	BSLParserRULE_elsifBranch               = 47
	BSLParserRULE_elseBranch                = 48
	BSLParserRULE_whileStatement            = 49
	BSLParserRULE_forStatement              = 50
	BSLParserRULE_forEachStatement          = 51
	BSLParserRULE_tryStatement              = 52
	BSLParserRULE_returnStatement           = 53
	BSLParserRULE_executeStatement          = 54
	BSLParserRULE_callStatement             = 55
	BSLParserRULE_waitStatement             = 56
	BSLParserRULE_labelName                 = 57
	BSLParserRULE_label                     = 58
	BSLParserRULE_gotoStatement             = 59
	BSLParserRULE_tryCodeBlock              = 60
	BSLParserRULE_exceptCodeBlock           = 61
	BSLParserRULE_event                     = 62
	BSLParserRULE_handler                   = 63
	BSLParserRULE_addHandlerStatement       = 64
	BSLParserRULE_removeHandlerStatement    = 65
	BSLParserRULE_ternaryOperator           = 66
	BSLParserRULE_waitExpression            = 67
	BSLParserRULE_fileCodeBlockBeforeSub    = 68
	BSLParserRULE_fileCodeBlock             = 69
	BSLParserRULE_codeBlock                 = 70
	BSLParserRULE_numeric                   = 71
	BSLParserRULE_paramList                 = 72
	BSLParserRULE_param                     = 73
	BSLParserRULE_defaultValue              = 74
	BSLParserRULE_constValue                = 75
	BSLParserRULE_multilineString           = 76
	BSLParserRULE_string                    = 77
	BSLParserRULE_statement                 = 78
	BSLParserRULE_assignment                = 79
	BSLParserRULE_callParamList             = 80
	BSLParserRULE_callParam                 = 81
	BSLParserRULE_expression                = 82
	BSLParserRULE_operation                 = 83
	BSLParserRULE_compareOperation          = 84
	BSLParserRULE_boolOperation             = 85
	BSLParserRULE_unaryModifier             = 86
	BSLParserRULE_member                    = 87
	BSLParserRULE_newwExpression            = 88
	BSLParserRULE_typeName                  = 89
	BSLParserRULE_methodCall                = 90
	BSLParserRULE_globalMethodCall          = 91
	BSLParserRULE_methodName                = 92
	BSLParserRULE_complexIdentifier         = 93
	BSLParserRULE_modifier                  = 94
	BSLParserRULE_acceptor                  = 95
	BSLParserRULE_lValue                    = 96
	BSLParserRULE_accessCall                = 97
	BSLParserRULE_accessIndex               = 98
	BSLParserRULE_accessProperty            = 99
	BSLParserRULE_doCall                    = 100
	BSLParserRULE_compoundStatement         = 101
)

// IFileContext is an interface to support dynamic dispatch.
type IFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileContext differentiates from other interfaces.
	IsFileContext()
}

type FileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileContext() *FileContext {
	var p = new(FileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_file
	return p
}

func (*FileContext) IsFileContext() {}

func NewFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileContext {
	var p = new(FileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_file

	return p
}

func (s *FileContext) GetParser() antlr.Parser { return s.parser }

func (s *FileContext) FileCodeBlock() IFileCodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileCodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileCodeBlockContext)
}

func (s *FileContext) EOF() antlr.TerminalNode {
	return s.GetToken(BSLParserEOF, 0)
}

func (s *FileContext) Shebang() IShebangContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShebangContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShebangContext)
}

func (s *FileContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *FileContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *FileContext) ModuleVars() IModuleVarsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleVarsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleVarsContext)
}

func (s *FileContext) FileCodeBlockBeforeSub() IFileCodeBlockBeforeSubContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileCodeBlockBeforeSubContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileCodeBlockBeforeSubContext)
}

func (s *FileContext) Subs() ISubsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubsContext)
}

func (s *FileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterFile(s)
	}
}

func (s *FileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitFile(s)
	}
}

func (p *BSLParser) File() (localctx IFileContext) {
	this := p
	_ = this

	localctx = NewFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, BSLParserRULE_file)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(205)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(204)
			p.Shebang()
		}

	}
	p.SetState(210)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(207)
				p.Preprocessor()
			}

		}
		p.SetState(212)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext())
	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(213)
			p.ModuleVars()
		}

	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(216)
				p.Preprocessor()
			}

		}
		p.SetState(221)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(222)
			p.FileCodeBlockBeforeSub()
		}
		{
			p.SetState(223)
			p.Subs()
		}

	}
	{
		p.SetState(227)
		p.FileCodeBlock()
	}
	{
		p.SetState(228)
		p.Match(BSLParserEOF)
	}

	return localctx
}

// IShebangContext is an interface to support dynamic dispatch.
type IShebangContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShebangContext differentiates from other interfaces.
	IsShebangContext()
}

type ShebangContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShebangContext() *ShebangContext {
	var p = new(ShebangContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_shebang
	return p
}

func (*ShebangContext) IsShebangContext() {}

func NewShebangContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShebangContext {
	var p = new(ShebangContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_shebang

	return p
}

func (s *ShebangContext) GetParser() antlr.Parser { return s.parser }

func (s *ShebangContext) HASH() antlr.TerminalNode {
	return s.GetToken(BSLParserHASH, 0)
}

func (s *ShebangContext) PREPROC_EXCLAMATION_MARK() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_EXCLAMATION_MARK, 0)
}

func (s *ShebangContext) AllPREPROC_ANY() []antlr.TerminalNode {
	return s.GetTokens(BSLParserPREPROC_ANY)
}

func (s *ShebangContext) PREPROC_ANY(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_ANY, i)
}

func (s *ShebangContext) AllPREPROC_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(BSLParserPREPROC_IDENTIFIER)
}

func (s *ShebangContext) PREPROC_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_IDENTIFIER, i)
}

func (s *ShebangContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShebangContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShebangContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterShebang(s)
	}
}

func (s *ShebangContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitShebang(s)
	}
}

func (p *BSLParser) Shebang() (localctx IShebangContext) {
	this := p
	_ = this

	localctx = NewShebangContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, BSLParserRULE_shebang)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(BSLParserHASH)
	}
	{
		p.SetState(231)
		p.Match(BSLParserPREPROC_EXCLAMATION_MARK)
	}
	p.SetState(235)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserPREPROC_IDENTIFIER || _la == BSLParserPREPROC_ANY {
		{
			p.SetState(232)
			_la = p.GetTokenStream().LA(1)

			if !(_la == BSLParserPREPROC_IDENTIFIER || _la == BSLParserPREPROC_ANY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(237)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUsedLibContext is an interface to support dynamic dispatch.
type IUsedLibContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUsedLibContext differentiates from other interfaces.
	IsUsedLibContext()
}

type UsedLibContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsedLibContext() *UsedLibContext {
	var p = new(UsedLibContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_usedLib
	return p
}

func (*UsedLibContext) IsUsedLibContext() {}

func NewUsedLibContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsedLibContext {
	var p = new(UsedLibContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_usedLib

	return p
}

func (s *UsedLibContext) GetParser() antlr.Parser { return s.parser }

func (s *UsedLibContext) PREPROC_STRING() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_STRING, 0)
}

func (s *UsedLibContext) PREPROC_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_IDENTIFIER, 0)
}

func (s *UsedLibContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsedLibContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsedLibContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterUsedLib(s)
	}
}

func (s *UsedLibContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitUsedLib(s)
	}
}

func (p *BSLParser) UsedLib() (localctx IUsedLibContext) {
	this := p
	_ = this

	localctx = NewUsedLibContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, BSLParserRULE_usedLib)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BSLParserPREPROC_STRING || _la == BSLParserPREPROC_IDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUseContext is an interface to support dynamic dispatch.
type IUseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseContext differentiates from other interfaces.
	IsUseContext()
}

type UseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseContext() *UseContext {
	var p = new(UseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_use
	return p
}

func (*UseContext) IsUseContext() {}

func NewUseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseContext {
	var p = new(UseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_use

	return p
}

func (s *UseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseContext) PREPROC_USE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_USE_KEYWORD, 0)
}

func (s *UseContext) UsedLib() IUsedLibContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsedLibContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsedLibContext)
}

func (s *UseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterUse(s)
	}
}

func (s *UseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitUse(s)
	}
}

func (p *BSLParser) Use() (localctx IUseContext) {
	this := p
	_ = this

	localctx = NewUseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, BSLParserRULE_use)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(240)
		p.Match(BSLParserPREPROC_USE_KEYWORD)
	}
	{
		p.SetState(241)
		p.UsedLib()
	}

	return localctx
}

// IRegionStartContext is an interface to support dynamic dispatch.
type IRegionStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegionStartContext differentiates from other interfaces.
	IsRegionStartContext()
}

type RegionStartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegionStartContext() *RegionStartContext {
	var p = new(RegionStartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_regionStart
	return p
}

func (*RegionStartContext) IsRegionStartContext() {}

func NewRegionStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegionStartContext {
	var p = new(RegionStartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_regionStart

	return p
}

func (s *RegionStartContext) GetParser() antlr.Parser { return s.parser }

func (s *RegionStartContext) PREPROC_REGION() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_REGION, 0)
}

func (s *RegionStartContext) RegionName() IRegionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegionNameContext)
}

func (s *RegionStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegionStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegionStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterRegionStart(s)
	}
}

func (s *RegionStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitRegionStart(s)
	}
}

func (p *BSLParser) RegionStart() (localctx IRegionStartContext) {
	this := p
	_ = this

	localctx = NewRegionStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, BSLParserRULE_regionStart)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(243)
		p.Match(BSLParserPREPROC_REGION)
	}
	{
		p.SetState(244)
		p.RegionName()
	}

	return localctx
}

// IRegionEndContext is an interface to support dynamic dispatch.
type IRegionEndContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegionEndContext differentiates from other interfaces.
	IsRegionEndContext()
}

type RegionEndContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegionEndContext() *RegionEndContext {
	var p = new(RegionEndContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_regionEnd
	return p
}

func (*RegionEndContext) IsRegionEndContext() {}

func NewRegionEndContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegionEndContext {
	var p = new(RegionEndContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_regionEnd

	return p
}

func (s *RegionEndContext) GetParser() antlr.Parser { return s.parser }

func (s *RegionEndContext) PREPROC_END_REGION() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_END_REGION, 0)
}

func (s *RegionEndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegionEndContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegionEndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterRegionEnd(s)
	}
}

func (s *RegionEndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitRegionEnd(s)
	}
}

func (p *BSLParser) RegionEnd() (localctx IRegionEndContext) {
	this := p
	_ = this

	localctx = NewRegionEndContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, BSLParserRULE_regionEnd)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(246)
		p.Match(BSLParserPREPROC_END_REGION)
	}

	return localctx
}

// IRegionNameContext is an interface to support dynamic dispatch.
type IRegionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRegionNameContext differentiates from other interfaces.
	IsRegionNameContext()
}

type RegionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRegionNameContext() *RegionNameContext {
	var p = new(RegionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_regionName
	return p
}

func (*RegionNameContext) IsRegionNameContext() {}

func NewRegionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RegionNameContext {
	var p = new(RegionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_regionName

	return p
}

func (s *RegionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RegionNameContext) PREPROC_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_IDENTIFIER, 0)
}

func (s *RegionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RegionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterRegionName(s)
	}
}

func (s *RegionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitRegionName(s)
	}
}

func (p *BSLParser) RegionName() (localctx IRegionNameContext) {
	this := p
	_ = this

	localctx = NewRegionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, BSLParserRULE_regionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(248)
		p.Match(BSLParserPREPROC_IDENTIFIER)
	}

	return localctx
}

// IPreproc_ifContext is an interface to support dynamic dispatch.
type IPreproc_ifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_ifContext differentiates from other interfaces.
	IsPreproc_ifContext()
}

type Preproc_ifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_ifContext() *Preproc_ifContext {
	var p = new(Preproc_ifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_if
	return p
}

func (*Preproc_ifContext) IsPreproc_ifContext() {}

func NewPreproc_ifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_ifContext {
	var p = new(Preproc_ifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_if

	return p
}

func (s *Preproc_ifContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_ifContext) PREPROC_IF_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_IF_KEYWORD, 0)
}

func (s *Preproc_ifContext) Preproc_expression() IPreproc_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_expressionContext)
}

func (s *Preproc_ifContext) PREPROC_THEN_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_THEN_KEYWORD, 0)
}

func (s *Preproc_ifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_ifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_ifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_if(s)
	}
}

func (s *Preproc_ifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_if(s)
	}
}

func (p *BSLParser) Preproc_if() (localctx IPreproc_ifContext) {
	this := p
	_ = this

	localctx = NewPreproc_ifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, BSLParserRULE_preproc_if)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(250)
		p.Match(BSLParserPREPROC_IF_KEYWORD)
	}
	{
		p.SetState(251)
		p.Preproc_expression()
	}
	{
		p.SetState(252)
		p.Match(BSLParserPREPROC_THEN_KEYWORD)
	}

	return localctx
}

// IPreproc_elsifContext is an interface to support dynamic dispatch.
type IPreproc_elsifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_elsifContext differentiates from other interfaces.
	IsPreproc_elsifContext()
}

type Preproc_elsifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_elsifContext() *Preproc_elsifContext {
	var p = new(Preproc_elsifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_elsif
	return p
}

func (*Preproc_elsifContext) IsPreproc_elsifContext() {}

func NewPreproc_elsifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_elsifContext {
	var p = new(Preproc_elsifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_elsif

	return p
}

func (s *Preproc_elsifContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_elsifContext) PREPROC_ELSIF_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_ELSIF_KEYWORD, 0)
}

func (s *Preproc_elsifContext) Preproc_expression() IPreproc_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_expressionContext)
}

func (s *Preproc_elsifContext) PREPROC_THEN_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_THEN_KEYWORD, 0)
}

func (s *Preproc_elsifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_elsifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_elsifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_elsif(s)
	}
}

func (s *Preproc_elsifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_elsif(s)
	}
}

func (p *BSLParser) Preproc_elsif() (localctx IPreproc_elsifContext) {
	this := p
	_ = this

	localctx = NewPreproc_elsifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, BSLParserRULE_preproc_elsif)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Match(BSLParserPREPROC_ELSIF_KEYWORD)
	}
	{
		p.SetState(255)
		p.Preproc_expression()
	}
	{
		p.SetState(256)
		p.Match(BSLParserPREPROC_THEN_KEYWORD)
	}

	return localctx
}

// IPreproc_elseContext is an interface to support dynamic dispatch.
type IPreproc_elseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_elseContext differentiates from other interfaces.
	IsPreproc_elseContext()
}

type Preproc_elseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_elseContext() *Preproc_elseContext {
	var p = new(Preproc_elseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_else
	return p
}

func (*Preproc_elseContext) IsPreproc_elseContext() {}

func NewPreproc_elseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_elseContext {
	var p = new(Preproc_elseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_else

	return p
}

func (s *Preproc_elseContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_elseContext) PREPROC_ELSE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_ELSE_KEYWORD, 0)
}

func (s *Preproc_elseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_elseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_elseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_else(s)
	}
}

func (s *Preproc_elseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_else(s)
	}
}

func (p *BSLParser) Preproc_else() (localctx IPreproc_elseContext) {
	this := p
	_ = this

	localctx = NewPreproc_elseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, BSLParserRULE_preproc_else)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(258)
		p.Match(BSLParserPREPROC_ELSE_KEYWORD)
	}

	return localctx
}

// IPreproc_endifContext is an interface to support dynamic dispatch.
type IPreproc_endifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_endifContext differentiates from other interfaces.
	IsPreproc_endifContext()
}

type Preproc_endifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_endifContext() *Preproc_endifContext {
	var p = new(Preproc_endifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_endif
	return p
}

func (*Preproc_endifContext) IsPreproc_endifContext() {}

func NewPreproc_endifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_endifContext {
	var p = new(Preproc_endifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_endif

	return p
}

func (s *Preproc_endifContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_endifContext) PREPROC_ENDIF_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_ENDIF_KEYWORD, 0)
}

func (s *Preproc_endifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_endifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_endifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_endif(s)
	}
}

func (s *Preproc_endifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_endif(s)
	}
}

func (p *BSLParser) Preproc_endif() (localctx IPreproc_endifContext) {
	this := p
	_ = this

	localctx = NewPreproc_endifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, BSLParserRULE_preproc_endif)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(260)
		p.Match(BSLParserPREPROC_ENDIF_KEYWORD)
	}

	return localctx
}

// IPreproc_expressionContext is an interface to support dynamic dispatch.
type IPreproc_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_expressionContext differentiates from other interfaces.
	IsPreproc_expressionContext()
}

type Preproc_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_expressionContext() *Preproc_expressionContext {
	var p = new(Preproc_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_expression
	return p
}

func (*Preproc_expressionContext) IsPreproc_expressionContext() {}

func NewPreproc_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_expressionContext {
	var p = new(Preproc_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_expression

	return p
}

func (s *Preproc_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_expressionContext) PREPROC_LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_LPAREN, 0)
}

func (s *Preproc_expressionContext) Preproc_expression() IPreproc_expressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_expressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_expressionContext)
}

func (s *Preproc_expressionContext) PREPROC_RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_RPAREN, 0)
}

func (s *Preproc_expressionContext) PREPROC_NOT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_NOT_KEYWORD, 0)
}

func (s *Preproc_expressionContext) Preproc_logicalExpression() IPreproc_logicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_logicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_logicalExpressionContext)
}

func (s *Preproc_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_expression(s)
	}
}

func (s *Preproc_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_expression(s)
	}
}

func (p *BSLParser) Preproc_expression() (localctx IPreproc_expressionContext) {
	this := p
	_ = this

	localctx = NewPreproc_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, BSLParserRULE_preproc_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(270)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == BSLParserPREPROC_NOT_KEYWORD {
			{
				p.SetState(262)
				p.Match(BSLParserPREPROC_NOT_KEYWORD)
			}

		}

		{
			p.SetState(265)
			p.Match(BSLParserPREPROC_LPAREN)
		}
		{
			p.SetState(266)
			p.Preproc_expression()
		}
		{
			p.SetState(267)
			p.Match(BSLParserPREPROC_RPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(269)
			p.Preproc_logicalExpression()
		}

	}

	return localctx
}

// IPreproc_logicalOperandContext is an interface to support dynamic dispatch.
type IPreproc_logicalOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_logicalOperandContext differentiates from other interfaces.
	IsPreproc_logicalOperandContext()
}

type Preproc_logicalOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_logicalOperandContext() *Preproc_logicalOperandContext {
	var p = new(Preproc_logicalOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_logicalOperand
	return p
}

func (*Preproc_logicalOperandContext) IsPreproc_logicalOperandContext() {}

func NewPreproc_logicalOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_logicalOperandContext {
	var p = new(Preproc_logicalOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_logicalOperand

	return p
}

func (s *Preproc_logicalOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_logicalOperandContext) PREPROC_LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_LPAREN, 0)
}

func (s *Preproc_logicalOperandContext) Preproc_logicalOperand() IPreproc_logicalOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_logicalOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_logicalOperandContext)
}

func (s *Preproc_logicalOperandContext) PREPROC_RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_RPAREN, 0)
}

func (s *Preproc_logicalOperandContext) PREPROC_NOT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_NOT_KEYWORD, 0)
}

func (s *Preproc_logicalOperandContext) Preproc_symbol() IPreproc_symbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_symbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_symbolContext)
}

func (s *Preproc_logicalOperandContext) Preproc_logicalExpression() IPreproc_logicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_logicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_logicalExpressionContext)
}

func (s *Preproc_logicalOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_logicalOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_logicalOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_logicalOperand(s)
	}
}

func (s *Preproc_logicalOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_logicalOperand(s)
	}
}

func (p *BSLParser) Preproc_logicalOperand() (localctx IPreproc_logicalOperandContext) {
	this := p
	_ = this

	localctx = NewPreproc_logicalOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, BSLParserRULE_preproc_logicalOperand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(272)
			p.Match(BSLParserPREPROC_LPAREN)
		}
		p.SetState(274)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(273)
				p.Match(BSLParserPREPROC_NOT_KEYWORD)
			}

		}
		{
			p.SetState(276)
			p.Preproc_logicalOperand()
		}
		{
			p.SetState(277)
			p.Match(BSLParserPREPROC_RPAREN)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(280)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == BSLParserPREPROC_NOT_KEYWORD {
			{
				p.SetState(279)
				p.Match(BSLParserPREPROC_NOT_KEYWORD)
			}

		}
		{
			p.SetState(282)
			p.Preproc_symbol()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(283)
			p.Match(BSLParserPREPROC_LPAREN)
		}
		{
			p.SetState(284)
			p.Preproc_logicalExpression()
		}
		{
			p.SetState(285)
			p.Match(BSLParserPREPROC_RPAREN)
		}

	}

	return localctx
}

// IPreproc_logicalExpressionContext is an interface to support dynamic dispatch.
type IPreproc_logicalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_logicalExpressionContext differentiates from other interfaces.
	IsPreproc_logicalExpressionContext()
}

type Preproc_logicalExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_logicalExpressionContext() *Preproc_logicalExpressionContext {
	var p = new(Preproc_logicalExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_logicalExpression
	return p
}

func (*Preproc_logicalExpressionContext) IsPreproc_logicalExpressionContext() {}

func NewPreproc_logicalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_logicalExpressionContext {
	var p = new(Preproc_logicalExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_logicalExpression

	return p
}

func (s *Preproc_logicalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_logicalExpressionContext) AllPreproc_logicalOperand() []IPreproc_logicalOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreproc_logicalOperandContext); ok {
			len++
		}
	}

	tst := make([]IPreproc_logicalOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreproc_logicalOperandContext); ok {
			tst[i] = t.(IPreproc_logicalOperandContext)
			i++
		}
	}

	return tst
}

func (s *Preproc_logicalExpressionContext) Preproc_logicalOperand(i int) IPreproc_logicalOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_logicalOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_logicalOperandContext)
}

func (s *Preproc_logicalExpressionContext) AllPreproc_boolOperation() []IPreproc_boolOperationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreproc_boolOperationContext); ok {
			len++
		}
	}

	tst := make([]IPreproc_boolOperationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreproc_boolOperationContext); ok {
			tst[i] = t.(IPreproc_boolOperationContext)
			i++
		}
	}

	return tst
}

func (s *Preproc_logicalExpressionContext) Preproc_boolOperation(i int) IPreproc_boolOperationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_boolOperationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_boolOperationContext)
}

func (s *Preproc_logicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_logicalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_logicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_logicalExpression(s)
	}
}

func (s *Preproc_logicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_logicalExpression(s)
	}
}

func (p *BSLParser) Preproc_logicalExpression() (localctx IPreproc_logicalExpressionContext) {
	this := p
	_ = this

	localctx = NewPreproc_logicalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, BSLParserRULE_preproc_logicalExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(289)
		p.Preproc_logicalOperand()
	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserPREPROC_OR_KEYWORD || _la == BSLParserPREPROC_AND_KEYWORD {
		{
			p.SetState(290)
			p.Preproc_boolOperation()
		}
		{
			p.SetState(291)
			p.Preproc_logicalOperand()
		}

		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPreproc_symbolContext is an interface to support dynamic dispatch.
type IPreproc_symbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_symbolContext differentiates from other interfaces.
	IsPreproc_symbolContext()
}

type Preproc_symbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_symbolContext() *Preproc_symbolContext {
	var p = new(Preproc_symbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_symbol
	return p
}

func (*Preproc_symbolContext) IsPreproc_symbolContext() {}

func NewPreproc_symbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_symbolContext {
	var p = new(Preproc_symbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_symbol

	return p
}

func (s *Preproc_symbolContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_symbolContext) PREPROC_CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_CLIENT_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_ATCLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_ATCLIENT_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_SERVER_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_ATSERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_ATSERVER_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_MOBILEAPPCLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_MOBILEAPPCLIENT_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_MOBILEAPPSERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_MOBILEAPPSERVER_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_MOBILECLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_MOBILECLIENT_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_THICKCLIENTORDINARYAPPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_THICKCLIENTORDINARYAPPLICATION_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_THICKCLIENTMANAGEDAPPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_THICKCLIENTMANAGEDAPPLICATION_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_EXTERNALCONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_EXTERNALCONNECTION_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_THINCLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_THINCLIENT_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_WEBCLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_WEBCLIENT_SYMBOL, 0)
}

func (s *Preproc_symbolContext) PREPROC_MOBILE_STANDALONE_SERVER() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_MOBILE_STANDALONE_SERVER, 0)
}

func (s *Preproc_symbolContext) PREPROC_LINUX() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_LINUX, 0)
}

func (s *Preproc_symbolContext) PREPROC_WINDOWS() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_WINDOWS, 0)
}

func (s *Preproc_symbolContext) PREPROC_MACOS() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_MACOS, 0)
}

func (s *Preproc_symbolContext) Preproc_unknownSymbol() IPreproc_unknownSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_unknownSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_unknownSymbolContext)
}

func (s *Preproc_symbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_symbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_symbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_symbol(s)
	}
}

func (s *Preproc_symbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_symbol(s)
	}
}

func (p *BSLParser) Preproc_symbol() (localctx IPreproc_symbolContext) {
	this := p
	_ = this

	localctx = NewPreproc_symbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, BSLParserRULE_preproc_symbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(315)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserPREPROC_CLIENT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(298)
			p.Match(BSLParserPREPROC_CLIENT_SYMBOL)
		}

	case BSLParserPREPROC_ATCLIENT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(299)
			p.Match(BSLParserPREPROC_ATCLIENT_SYMBOL)
		}

	case BSLParserPREPROC_SERVER_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(300)
			p.Match(BSLParserPREPROC_SERVER_SYMBOL)
		}

	case BSLParserPREPROC_ATSERVER_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(301)
			p.Match(BSLParserPREPROC_ATSERVER_SYMBOL)
		}

	case BSLParserPREPROC_MOBILEAPPCLIENT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(302)
			p.Match(BSLParserPREPROC_MOBILEAPPCLIENT_SYMBOL)
		}

	case BSLParserPREPROC_MOBILEAPPSERVER_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(303)
			p.Match(BSLParserPREPROC_MOBILEAPPSERVER_SYMBOL)
		}

	case BSLParserPREPROC_MOBILECLIENT_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(304)
			p.Match(BSLParserPREPROC_MOBILECLIENT_SYMBOL)
		}

	case BSLParserPREPROC_THICKCLIENTORDINARYAPPLICATION_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(305)
			p.Match(BSLParserPREPROC_THICKCLIENTORDINARYAPPLICATION_SYMBOL)
		}

	case BSLParserPREPROC_THICKCLIENTMANAGEDAPPLICATION_SYMBOL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(306)
			p.Match(BSLParserPREPROC_THICKCLIENTMANAGEDAPPLICATION_SYMBOL)
		}

	case BSLParserPREPROC_EXTERNALCONNECTION_SYMBOL:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(307)
			p.Match(BSLParserPREPROC_EXTERNALCONNECTION_SYMBOL)
		}

	case BSLParserPREPROC_THINCLIENT_SYMBOL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(308)
			p.Match(BSLParserPREPROC_THINCLIENT_SYMBOL)
		}

	case BSLParserPREPROC_WEBCLIENT_SYMBOL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(309)
			p.Match(BSLParserPREPROC_WEBCLIENT_SYMBOL)
		}

	case BSLParserPREPROC_MOBILE_STANDALONE_SERVER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(310)
			p.Match(BSLParserPREPROC_MOBILE_STANDALONE_SERVER)
		}

	case BSLParserPREPROC_LINUX:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(311)
			p.Match(BSLParserPREPROC_LINUX)
		}

	case BSLParserPREPROC_WINDOWS:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(312)
			p.Match(BSLParserPREPROC_WINDOWS)
		}

	case BSLParserPREPROC_MACOS:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(313)
			p.Match(BSLParserPREPROC_MACOS)
		}

	case BSLParserPREPROC_IDENTIFIER:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(314)
			p.Preproc_unknownSymbol()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPreproc_unknownSymbolContext is an interface to support dynamic dispatch.
type IPreproc_unknownSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_unknownSymbolContext differentiates from other interfaces.
	IsPreproc_unknownSymbolContext()
}

type Preproc_unknownSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_unknownSymbolContext() *Preproc_unknownSymbolContext {
	var p = new(Preproc_unknownSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_unknownSymbol
	return p
}

func (*Preproc_unknownSymbolContext) IsPreproc_unknownSymbolContext() {}

func NewPreproc_unknownSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_unknownSymbolContext {
	var p = new(Preproc_unknownSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_unknownSymbol

	return p
}

func (s *Preproc_unknownSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_unknownSymbolContext) PREPROC_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_IDENTIFIER, 0)
}

func (s *Preproc_unknownSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_unknownSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_unknownSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_unknownSymbol(s)
	}
}

func (s *Preproc_unknownSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_unknownSymbol(s)
	}
}

func (p *BSLParser) Preproc_unknownSymbol() (localctx IPreproc_unknownSymbolContext) {
	this := p
	_ = this

	localctx = NewPreproc_unknownSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, BSLParserRULE_preproc_unknownSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(317)
		p.Match(BSLParserPREPROC_IDENTIFIER)
	}

	return localctx
}

// IPreproc_boolOperationContext is an interface to support dynamic dispatch.
type IPreproc_boolOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreproc_boolOperationContext differentiates from other interfaces.
	IsPreproc_boolOperationContext()
}

type Preproc_boolOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreproc_boolOperationContext() *Preproc_boolOperationContext {
	var p = new(Preproc_boolOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preproc_boolOperation
	return p
}

func (*Preproc_boolOperationContext) IsPreproc_boolOperationContext() {}

func NewPreproc_boolOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Preproc_boolOperationContext {
	var p = new(Preproc_boolOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preproc_boolOperation

	return p
}

func (s *Preproc_boolOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *Preproc_boolOperationContext) PREPROC_OR_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_OR_KEYWORD, 0)
}

func (s *Preproc_boolOperationContext) PREPROC_AND_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPREPROC_AND_KEYWORD, 0)
}

func (s *Preproc_boolOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Preproc_boolOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Preproc_boolOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreproc_boolOperation(s)
	}
}

func (s *Preproc_boolOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreproc_boolOperation(s)
	}
}

func (p *BSLParser) Preproc_boolOperation() (localctx IPreproc_boolOperationContext) {
	this := p
	_ = this

	localctx = NewPreproc_boolOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, BSLParserRULE_preproc_boolOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(319)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BSLParserPREPROC_OR_KEYWORD || _la == BSLParserPREPROC_AND_KEYWORD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPreprocessorContext is an interface to support dynamic dispatch.
type IPreprocessorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPreprocessorContext differentiates from other interfaces.
	IsPreprocessorContext()
}

type PreprocessorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPreprocessorContext() *PreprocessorContext {
	var p = new(PreprocessorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_preprocessor
	return p
}

func (*PreprocessorContext) IsPreprocessorContext() {}

func NewPreprocessorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreprocessorContext {
	var p = new(PreprocessorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_preprocessor

	return p
}

func (s *PreprocessorContext) GetParser() antlr.Parser { return s.parser }

func (s *PreprocessorContext) HASH() antlr.TerminalNode {
	return s.GetToken(BSLParserHASH, 0)
}

func (s *PreprocessorContext) RegionStart() IRegionStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegionStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegionStartContext)
}

func (s *PreprocessorContext) RegionEnd() IRegionEndContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRegionEndContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRegionEndContext)
}

func (s *PreprocessorContext) Preproc_if() IPreproc_ifContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_ifContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_ifContext)
}

func (s *PreprocessorContext) Preproc_elsif() IPreproc_elsifContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_elsifContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_elsifContext)
}

func (s *PreprocessorContext) Preproc_else() IPreproc_elseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_elseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_elseContext)
}

func (s *PreprocessorContext) Preproc_endif() IPreproc_endifContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreproc_endifContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreproc_endifContext)
}

func (s *PreprocessorContext) Use() IUseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseContext)
}

func (s *PreprocessorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreprocessorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreprocessorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterPreprocessor(s)
	}
}

func (s *PreprocessorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitPreprocessor(s)
	}
}

func (p *BSLParser) Preprocessor() (localctx IPreprocessorContext) {
	this := p
	_ = this

	localctx = NewPreprocessorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, BSLParserRULE_preprocessor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(321)
		p.Match(BSLParserHASH)
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserPREPROC_REGION:
		{
			p.SetState(322)
			p.RegionStart()
		}

	case BSLParserPREPROC_END_REGION:
		{
			p.SetState(323)
			p.RegionEnd()
		}

	case BSLParserPREPROC_IF_KEYWORD:
		{
			p.SetState(324)
			p.Preproc_if()
		}

	case BSLParserPREPROC_ELSIF_KEYWORD:
		{
			p.SetState(325)
			p.Preproc_elsif()
		}

	case BSLParserPREPROC_ELSE_KEYWORD:
		{
			p.SetState(326)
			p.Preproc_else()
		}

	case BSLParserPREPROC_ENDIF_KEYWORD:
		{
			p.SetState(327)
			p.Preproc_endif()
		}

	case BSLParserPREPROC_USE_KEYWORD:
		{
			p.SetState(328)
			p.Use()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompilerDirectiveSymbolContext is an interface to support dynamic dispatch.
type ICompilerDirectiveSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilerDirectiveSymbolContext differentiates from other interfaces.
	IsCompilerDirectiveSymbolContext()
}

type CompilerDirectiveSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerDirectiveSymbolContext() *CompilerDirectiveSymbolContext {
	var p = new(CompilerDirectiveSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_compilerDirectiveSymbol
	return p
}

func (*CompilerDirectiveSymbolContext) IsCompilerDirectiveSymbolContext() {}

func NewCompilerDirectiveSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerDirectiveSymbolContext {
	var p = new(CompilerDirectiveSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_compilerDirectiveSymbol

	return p
}

func (s *CompilerDirectiveSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerDirectiveSymbolContext) ANNOTATION_ATSERVERNOCONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_ATSERVERNOCONTEXT_SYMBOL, 0)
}

func (s *CompilerDirectiveSymbolContext) ANNOTATION_ATCLIENTATSERVERNOCONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_ATCLIENTATSERVERNOCONTEXT_SYMBOL, 0)
}

func (s *CompilerDirectiveSymbolContext) ANNOTATION_ATCLIENTATSERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_ATCLIENTATSERVER_SYMBOL, 0)
}

func (s *CompilerDirectiveSymbolContext) ANNOTATION_ATCLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_ATCLIENT_SYMBOL, 0)
}

func (s *CompilerDirectiveSymbolContext) ANNOTATION_ATSERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_ATSERVER_SYMBOL, 0)
}

func (s *CompilerDirectiveSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerDirectiveSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerDirectiveSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCompilerDirectiveSymbol(s)
	}
}

func (s *CompilerDirectiveSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCompilerDirectiveSymbol(s)
	}
}

func (p *BSLParser) CompilerDirectiveSymbol() (localctx ICompilerDirectiveSymbolContext) {
	this := p
	_ = this

	localctx = NewCompilerDirectiveSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, BSLParserRULE_compilerDirectiveSymbol)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(331)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICompilerDirectiveContext is an interface to support dynamic dispatch.
type ICompilerDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilerDirectiveContext differentiates from other interfaces.
	IsCompilerDirectiveContext()
}

type CompilerDirectiveContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilerDirectiveContext() *CompilerDirectiveContext {
	var p = new(CompilerDirectiveContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_compilerDirective
	return p
}

func (*CompilerDirectiveContext) IsCompilerDirectiveContext() {}

func NewCompilerDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilerDirectiveContext {
	var p = new(CompilerDirectiveContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_compilerDirective

	return p
}

func (s *CompilerDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilerDirectiveContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(BSLParserAMPERSAND, 0)
}

func (s *CompilerDirectiveContext) CompilerDirectiveSymbol() ICompilerDirectiveSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerDirectiveSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerDirectiveSymbolContext)
}

func (s *CompilerDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilerDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilerDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCompilerDirective(s)
	}
}

func (s *CompilerDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCompilerDirective(s)
	}
}

func (p *BSLParser) CompilerDirective() (localctx ICompilerDirectiveContext) {
	this := p
	_ = this

	localctx = NewCompilerDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, BSLParserRULE_compilerDirective)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(333)
		p.Match(BSLParserAMPERSAND)
	}
	{
		p.SetState(334)
		p.CompilerDirectiveSymbol()
	}

	return localctx
}

// IAnnotationNameContext is an interface to support dynamic dispatch.
type IAnnotationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationNameContext differentiates from other interfaces.
	IsAnnotationNameContext()
}

type AnnotationNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationNameContext() *AnnotationNameContext {
	var p = new(AnnotationNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_annotationName
	return p
}

func (*AnnotationNameContext) IsAnnotationNameContext() {}

func NewAnnotationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationNameContext {
	var p = new(AnnotationNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_annotationName

	return p
}

func (s *AnnotationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationNameContext) ANNOTATION_CUSTOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_CUSTOM_SYMBOL, 0)
}

func (s *AnnotationNameContext) ANNOTATION_BEFORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_BEFORE_SYMBOL, 0)
}

func (s *AnnotationNameContext) ANNOTATION_AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_AFTER_SYMBOL, 0)
}

func (s *AnnotationNameContext) ANNOTATION_AROUND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_AROUND_SYMBOL, 0)
}

func (s *AnnotationNameContext) ANNOTATION_CHANGEANDVALIDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(BSLParserANNOTATION_CHANGEANDVALIDATE_SYMBOL, 0)
}

func (s *AnnotationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAnnotationName(s)
	}
}

func (s *AnnotationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAnnotationName(s)
	}
}

func (p *BSLParser) AnnotationName() (localctx IAnnotationNameContext) {
	this := p
	_ = this

	localctx = NewAnnotationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, BSLParserRULE_annotationName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(336)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-117)) & ^0x3f) == 0 && ((int64(1)<<(_la-117))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAnnotationParamNameContext is an interface to support dynamic dispatch.
type IAnnotationParamNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationParamNameContext differentiates from other interfaces.
	IsAnnotationParamNameContext()
}

type AnnotationParamNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationParamNameContext() *AnnotationParamNameContext {
	var p = new(AnnotationParamNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_annotationParamName
	return p
}

func (*AnnotationParamNameContext) IsAnnotationParamNameContext() {}

func NewAnnotationParamNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationParamNameContext {
	var p = new(AnnotationParamNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_annotationParamName

	return p
}

func (s *AnnotationParamNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationParamNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *AnnotationParamNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationParamNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationParamNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAnnotationParamName(s)
	}
}

func (s *AnnotationParamNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAnnotationParamName(s)
	}
}

func (p *BSLParser) AnnotationParamName() (localctx IAnnotationParamNameContext) {
	this := p
	_ = this

	localctx = NewAnnotationParamNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, BSLParserRULE_annotationParamName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(338)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_annotation
	return p
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(BSLParserAMPERSAND, 0)
}

func (s *AnnotationContext) AnnotationName() IAnnotationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationNameContext)
}

func (s *AnnotationContext) AnnotationParams() IAnnotationParamsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationParamsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationParamsContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (p *BSLParser) Annotation() (localctx IAnnotationContext) {
	this := p
	_ = this

	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, BSLParserRULE_annotation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(340)
		p.Match(BSLParserAMPERSAND)
	}
	{
		p.SetState(341)
		p.AnnotationName()
	}
	p.SetState(343)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserLPAREN {
		{
			p.SetState(342)
			p.AnnotationParams()
		}

	}

	return localctx
}

// IAnnotationParamsContext is an interface to support dynamic dispatch.
type IAnnotationParamsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationParamsContext differentiates from other interfaces.
	IsAnnotationParamsContext()
}

type AnnotationParamsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationParamsContext() *AnnotationParamsContext {
	var p = new(AnnotationParamsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_annotationParams
	return p
}

func (*AnnotationParamsContext) IsAnnotationParamsContext() {}

func NewAnnotationParamsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationParamsContext {
	var p = new(AnnotationParamsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_annotationParams

	return p
}

func (s *AnnotationParamsContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationParamsContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserLPAREN, 0)
}

func (s *AnnotationParamsContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserRPAREN, 0)
}

func (s *AnnotationParamsContext) AllAnnotationParam() []IAnnotationParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationParamContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationParamContext); ok {
			tst[i] = t.(IAnnotationParamContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationParamsContext) AnnotationParam(i int) IAnnotationParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationParamContext)
}

func (s *AnnotationParamsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BSLParserCOMMA)
}

func (s *AnnotationParamsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, i)
}

func (s *AnnotationParamsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationParamsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationParamsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAnnotationParams(s)
	}
}

func (s *AnnotationParamsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAnnotationParams(s)
	}
}

func (p *BSLParser) AnnotationParams() (localctx IAnnotationParamsContext) {
	this := p
	_ = this

	localctx = NewAnnotationParamsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, BSLParserRULE_annotationParams)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(345)
		p.Match(BSLParserLPAREN)
	}
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&548682084352) != 0 || _la == BSLParserIDENTIFIER {
		{
			p.SetState(346)
			p.AnnotationParam()
		}
		p.SetState(351)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == BSLParserCOMMA {
			{
				p.SetState(347)
				p.Match(BSLParserCOMMA)
			}
			{
				p.SetState(348)
				p.AnnotationParam()
			}

			p.SetState(353)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(356)
		p.Match(BSLParserRPAREN)
	}

	return localctx
}

// IAnnotationParamContext is an interface to support dynamic dispatch.
type IAnnotationParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnnotationParamContext differentiates from other interfaces.
	IsAnnotationParamContext()
}

type AnnotationParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationParamContext() *AnnotationParamContext {
	var p = new(AnnotationParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_annotationParam
	return p
}

func (*AnnotationParamContext) IsAnnotationParamContext() {}

func NewAnnotationParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationParamContext {
	var p = new(AnnotationParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_annotationParam

	return p
}

func (s *AnnotationParamContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationParamContext) AnnotationParamName() IAnnotationParamNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationParamNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationParamNameContext)
}

func (s *AnnotationParamContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(BSLParserASSIGN, 0)
}

func (s *AnnotationParamContext) ConstValue() IConstValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *AnnotationParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAnnotationParam(s)
	}
}

func (s *AnnotationParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAnnotationParam(s)
	}
}

func (p *BSLParser) AnnotationParam() (localctx IAnnotationParamContext) {
	this := p
	_ = this

	localctx = NewAnnotationParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, BSLParserRULE_annotationParam)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(364)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(358)
			p.AnnotationParamName()
		}
		p.SetState(361)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == BSLParserASSIGN {
			{
				p.SetState(359)
				p.Match(BSLParserASSIGN)
			}
			{
				p.SetState(360)
				p.ConstValue()
			}

		}

	case BSLParserPLUS, BSLParserMINUS, BSLParserTRUE, BSLParserFALSE, BSLParserUNDEFINED, BSLParserNULL, BSLParserDECIMAL, BSLParserDATETIME, BSLParserFLOAT, BSLParserSTRING, BSLParserSTRINGSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(363)
			p.ConstValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IVar_nameContext is an interface to support dynamic dispatch.
type IVar_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVar_nameContext differentiates from other interfaces.
	IsVar_nameContext()
}

type Var_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVar_nameContext() *Var_nameContext {
	var p = new(Var_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_var_name
	return p
}

func (*Var_nameContext) IsVar_nameContext() {}

func NewVar_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Var_nameContext {
	var p = new(Var_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_var_name

	return p
}

func (s *Var_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Var_nameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *Var_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Var_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Var_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterVar_name(s)
	}
}

func (s *Var_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitVar_name(s)
	}
}

func (p *BSLParser) Var_name() (localctx IVar_nameContext) {
	this := p
	_ = this

	localctx = NewVar_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, BSLParserRULE_var_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// IModuleVarsContext is an interface to support dynamic dispatch.
type IModuleVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleVarsContext differentiates from other interfaces.
	IsModuleVarsContext()
}

type ModuleVarsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleVarsContext() *ModuleVarsContext {
	var p = new(ModuleVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_moduleVars
	return p
}

func (*ModuleVarsContext) IsModuleVarsContext() {}

func NewModuleVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleVarsContext {
	var p = new(ModuleVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_moduleVars

	return p
}

func (s *ModuleVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleVarsContext) AllModuleVar() []IModuleVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleVarContext); ok {
			len++
		}
	}

	tst := make([]IModuleVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleVarContext); ok {
			tst[i] = t.(IModuleVarContext)
			i++
		}
	}

	return tst
}

func (s *ModuleVarsContext) ModuleVar(i int) IModuleVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleVarContext)
}

func (s *ModuleVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleVarsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterModuleVars(s)
	}
}

func (s *ModuleVarsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitModuleVars(s)
	}
}

func (p *BSLParser) ModuleVars() (localctx IModuleVarsContext) {
	this := p
	_ = this

	localctx = NewModuleVarsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, BSLParserRULE_moduleVars)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(368)
				p.ModuleVar()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(371)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}

	return localctx
}

// IModuleVarContext is an interface to support dynamic dispatch.
type IModuleVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleVarContext differentiates from other interfaces.
	IsModuleVarContext()
}

type ModuleVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleVarContext() *ModuleVarContext {
	var p = new(ModuleVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_moduleVar
	return p
}

func (*ModuleVarContext) IsModuleVarContext() {}

func NewModuleVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleVarContext {
	var p = new(ModuleVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_moduleVar

	return p
}

func (s *ModuleVarContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleVarContext) VAR_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserVAR_KEYWORD, 0)
}

func (s *ModuleVarContext) ModuleVarsList() IModuleVarsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleVarsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleVarsListContext)
}

func (s *ModuleVarContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *ModuleVarContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *ModuleVarContext) AllCompilerDirective() []ICompilerDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			len++
		}
	}

	tst := make([]ICompilerDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerDirectiveContext); ok {
			tst[i] = t.(ICompilerDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ModuleVarContext) CompilerDirective(i int) ICompilerDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerDirectiveContext)
}

func (s *ModuleVarContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ModuleVarContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ModuleVarContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(BSLParserSEMICOLON, 0)
}

func (s *ModuleVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterModuleVar(s)
	}
}

func (s *ModuleVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitModuleVar(s)
	}
}

func (p *BSLParser) ModuleVar() (localctx IModuleVarContext) {
	this := p
	_ = this

	localctx = NewModuleVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, BSLParserRULE_moduleVar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserAMPERSAND || _la == BSLParserHASH {
		p.SetState(376)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(373)
				p.Preprocessor()
			}

		case 2:
			{
				p.SetState(374)
				p.CompilerDirective()
			}

		case 3:
			{
				p.SetState(375)
				p.Annotation()
			}

		}

		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(381)
		p.Match(BSLParserVAR_KEYWORD)
	}
	{
		p.SetState(382)
		p.ModuleVarsList()
	}
	p.SetState(384)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(383)
			p.Match(BSLParserSEMICOLON)
		}

	}

	return localctx
}

// IModuleVarsListContext is an interface to support dynamic dispatch.
type IModuleVarsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleVarsListContext differentiates from other interfaces.
	IsModuleVarsListContext()
}

type ModuleVarsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleVarsListContext() *ModuleVarsListContext {
	var p = new(ModuleVarsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_moduleVarsList
	return p
}

func (*ModuleVarsListContext) IsModuleVarsListContext() {}

func NewModuleVarsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleVarsListContext {
	var p = new(ModuleVarsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_moduleVarsList

	return p
}

func (s *ModuleVarsListContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleVarsListContext) AllModuleVarDeclaration() []IModuleVarDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModuleVarDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IModuleVarDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModuleVarDeclarationContext); ok {
			tst[i] = t.(IModuleVarDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ModuleVarsListContext) ModuleVarDeclaration(i int) IModuleVarDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleVarDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleVarDeclarationContext)
}

func (s *ModuleVarsListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BSLParserCOMMA)
}

func (s *ModuleVarsListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, i)
}

func (s *ModuleVarsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleVarsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleVarsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterModuleVarsList(s)
	}
}

func (s *ModuleVarsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitModuleVarsList(s)
	}
}

func (p *BSLParser) ModuleVarsList() (localctx IModuleVarsListContext) {
	this := p
	_ = this

	localctx = NewModuleVarsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, BSLParserRULE_moduleVarsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(386)
		p.ModuleVarDeclaration()
	}
	p.SetState(391)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserCOMMA {
		{
			p.SetState(387)
			p.Match(BSLParserCOMMA)
		}
		{
			p.SetState(388)
			p.ModuleVarDeclaration()
		}

		p.SetState(393)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModuleVarDeclarationContext is an interface to support dynamic dispatch.
type IModuleVarDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleVarDeclarationContext differentiates from other interfaces.
	IsModuleVarDeclarationContext()
}

type ModuleVarDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleVarDeclarationContext() *ModuleVarDeclarationContext {
	var p = new(ModuleVarDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_moduleVarDeclaration
	return p
}

func (*ModuleVarDeclarationContext) IsModuleVarDeclarationContext() {}

func NewModuleVarDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleVarDeclarationContext {
	var p = new(ModuleVarDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_moduleVarDeclaration

	return p
}

func (s *ModuleVarDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleVarDeclarationContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *ModuleVarDeclarationContext) EXPORT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserEXPORT_KEYWORD, 0)
}

func (s *ModuleVarDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleVarDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleVarDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterModuleVarDeclaration(s)
	}
}

func (s *ModuleVarDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitModuleVarDeclaration(s)
	}
}

func (p *BSLParser) ModuleVarDeclaration() (localctx IModuleVarDeclarationContext) {
	this := p
	_ = this

	localctx = NewModuleVarDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, BSLParserRULE_moduleVarDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Var_name()
	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserEXPORT_KEYWORD {
		{
			p.SetState(395)
			p.Match(BSLParserEXPORT_KEYWORD)
		}

	}

	return localctx
}

// ISubVarsContext is an interface to support dynamic dispatch.
type ISubVarsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubVarsContext differentiates from other interfaces.
	IsSubVarsContext()
}

type SubVarsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubVarsContext() *SubVarsContext {
	var p = new(SubVarsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subVars
	return p
}

func (*SubVarsContext) IsSubVarsContext() {}

func NewSubVarsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubVarsContext {
	var p = new(SubVarsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subVars

	return p
}

func (s *SubVarsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubVarsContext) AllSubVar() []ISubVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubVarContext); ok {
			len++
		}
	}

	tst := make([]ISubVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubVarContext); ok {
			tst[i] = t.(ISubVarContext)
			i++
		}
	}

	return tst
}

func (s *SubVarsContext) SubVar(i int) ISubVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubVarContext)
}

func (s *SubVarsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubVarsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubVarsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubVars(s)
	}
}

func (s *SubVarsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubVars(s)
	}
}

func (p *BSLParser) SubVars() (localctx ISubVarsContext) {
	this := p
	_ = this

	localctx = NewSubVarsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, BSLParserRULE_subVars)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(398)
				p.SubVar()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(401)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}

	return localctx
}

// ISubVarContext is an interface to support dynamic dispatch.
type ISubVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubVarContext differentiates from other interfaces.
	IsSubVarContext()
}

type SubVarContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubVarContext() *SubVarContext {
	var p = new(SubVarContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subVar
	return p
}

func (*SubVarContext) IsSubVarContext() {}

func NewSubVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubVarContext {
	var p = new(SubVarContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subVar

	return p
}

func (s *SubVarContext) GetParser() antlr.Parser { return s.parser }

func (s *SubVarContext) VAR_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserVAR_KEYWORD, 0)
}

func (s *SubVarContext) SubVarsList() ISubVarsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubVarsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubVarsListContext)
}

func (s *SubVarContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *SubVarContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *SubVarContext) AllCompilerDirective() []ICompilerDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			len++
		}
	}

	tst := make([]ICompilerDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerDirectiveContext); ok {
			tst[i] = t.(ICompilerDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *SubVarContext) CompilerDirective(i int) ICompilerDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerDirectiveContext)
}

func (s *SubVarContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *SubVarContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *SubVarContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(BSLParserSEMICOLON, 0)
}

func (s *SubVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubVar(s)
	}
}

func (s *SubVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubVar(s)
	}
}

func (p *BSLParser) SubVar() (localctx ISubVarContext) {
	this := p
	_ = this

	localctx = NewSubVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, BSLParserRULE_subVar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserAMPERSAND || _la == BSLParserHASH {
		p.SetState(406)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(403)
				p.Preprocessor()
			}

		case 2:
			{
				p.SetState(404)
				p.CompilerDirective()
			}

		case 3:
			{
				p.SetState(405)
				p.Annotation()
			}

		}

		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(411)
		p.Match(BSLParserVAR_KEYWORD)
	}
	{
		p.SetState(412)
		p.SubVarsList()
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(413)
			p.Match(BSLParserSEMICOLON)
		}

	}

	return localctx
}

// ISubVarsListContext is an interface to support dynamic dispatch.
type ISubVarsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubVarsListContext differentiates from other interfaces.
	IsSubVarsListContext()
}

type SubVarsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubVarsListContext() *SubVarsListContext {
	var p = new(SubVarsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subVarsList
	return p
}

func (*SubVarsListContext) IsSubVarsListContext() {}

func NewSubVarsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubVarsListContext {
	var p = new(SubVarsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subVarsList

	return p
}

func (s *SubVarsListContext) GetParser() antlr.Parser { return s.parser }

func (s *SubVarsListContext) AllSubVarDeclaration() []ISubVarDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubVarDeclarationContext); ok {
			len++
		}
	}

	tst := make([]ISubVarDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubVarDeclarationContext); ok {
			tst[i] = t.(ISubVarDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *SubVarsListContext) SubVarDeclaration(i int) ISubVarDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubVarDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubVarDeclarationContext)
}

func (s *SubVarsListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BSLParserCOMMA)
}

func (s *SubVarsListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, i)
}

func (s *SubVarsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubVarsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubVarsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubVarsList(s)
	}
}

func (s *SubVarsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubVarsList(s)
	}
}

func (p *BSLParser) SubVarsList() (localctx ISubVarsListContext) {
	this := p
	_ = this

	localctx = NewSubVarsListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, BSLParserRULE_subVarsList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.SubVarDeclaration()
	}
	p.SetState(421)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserCOMMA {
		{
			p.SetState(417)
			p.Match(BSLParserCOMMA)
		}
		{
			p.SetState(418)
			p.SubVarDeclaration()
		}

		p.SetState(423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubVarDeclarationContext is an interface to support dynamic dispatch.
type ISubVarDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubVarDeclarationContext differentiates from other interfaces.
	IsSubVarDeclarationContext()
}

type SubVarDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubVarDeclarationContext() *SubVarDeclarationContext {
	var p = new(SubVarDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subVarDeclaration
	return p
}

func (*SubVarDeclarationContext) IsSubVarDeclarationContext() {}

func NewSubVarDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubVarDeclarationContext {
	var p = new(SubVarDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subVarDeclaration

	return p
}

func (s *SubVarDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SubVarDeclarationContext) Var_name() IVar_nameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVar_nameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVar_nameContext)
}

func (s *SubVarDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubVarDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubVarDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubVarDeclaration(s)
	}
}

func (s *SubVarDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubVarDeclaration(s)
	}
}

func (p *BSLParser) SubVarDeclaration() (localctx ISubVarDeclarationContext) {
	this := p
	_ = this

	localctx = NewSubVarDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, BSLParserRULE_subVarDeclaration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Var_name()
	}

	return localctx
}

// ISubNameContext is an interface to support dynamic dispatch.
type ISubNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubNameContext differentiates from other interfaces.
	IsSubNameContext()
}

type SubNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubNameContext() *SubNameContext {
	var p = new(SubNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subName
	return p
}

func (*SubNameContext) IsSubNameContext() {}

func NewSubNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubNameContext {
	var p = new(SubNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subName

	return p
}

func (s *SubNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SubNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *SubNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubName(s)
	}
}

func (s *SubNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubName(s)
	}
}

func (p *BSLParser) SubName() (localctx ISubNameContext) {
	this := p
	_ = this

	localctx = NewSubNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, BSLParserRULE_subName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// ISubsContext is an interface to support dynamic dispatch.
type ISubsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubsContext differentiates from other interfaces.
	IsSubsContext()
}

type SubsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubsContext() *SubsContext {
	var p = new(SubsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subs
	return p
}

func (*SubsContext) IsSubsContext() {}

func NewSubsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubsContext {
	var p = new(SubsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subs

	return p
}

func (s *SubsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubsContext) AllSub() []ISubContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubContext); ok {
			len++
		}
	}

	tst := make([]ISubContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubContext); ok {
			tst[i] = t.(ISubContext)
			i++
		}
	}

	return tst
}

func (s *SubsContext) Sub(i int) ISubContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubContext)
}

func (s *SubsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubs(s)
	}
}

func (s *SubsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubs(s)
	}
}

func (p *BSLParser) Subs() (localctx ISubsContext) {
	this := p
	_ = this

	localctx = NewSubsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, BSLParserRULE_subs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(428)
				p.Sub()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}

	return localctx
}

// ISubContext is an interface to support dynamic dispatch.
type ISubContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubContext differentiates from other interfaces.
	IsSubContext()
}

type SubContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubContext() *SubContext {
	var p = new(SubContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_sub
	return p
}

func (*SubContext) IsSubContext() {}

func NewSubContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubContext {
	var p = new(SubContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_sub

	return p
}

func (s *SubContext) GetParser() antlr.Parser { return s.parser }

func (s *SubContext) Procedure() IProcedureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureContext)
}

func (s *SubContext) Function() IFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}

func (s *SubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSub(s)
	}
}

func (s *SubContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSub(s)
	}
}

func (p *BSLParser) Sub() (localctx ISubContext) {
	this := p
	_ = this

	localctx = NewSubContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, BSLParserRULE_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(433)
			p.Procedure()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(434)
			p.Function()
		}

	}

	return localctx
}

// IProcedureContext is an interface to support dynamic dispatch.
type IProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureContext differentiates from other interfaces.
	IsProcedureContext()
}

type ProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureContext() *ProcedureContext {
	var p = new(ProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_procedure
	return p
}

func (*ProcedureContext) IsProcedureContext() {}

func NewProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureContext {
	var p = new(ProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_procedure

	return p
}

func (s *ProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureContext) ProcDeclaration() IProcDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcDeclarationContext)
}

func (s *ProcedureContext) SubCodeBlock() ISubCodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubCodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubCodeBlockContext)
}

func (s *ProcedureContext) ENDPROCEDURE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDPROCEDURE_KEYWORD, 0)
}

func (s *ProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterProcedure(s)
	}
}

func (s *ProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitProcedure(s)
	}
}

func (p *BSLParser) Procedure() (localctx IProcedureContext) {
	this := p
	_ = this

	localctx = NewProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, BSLParserRULE_procedure)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		p.ProcDeclaration()
	}
	{
		p.SetState(438)
		p.SubCodeBlock()
	}
	{
		p.SetState(439)
		p.Match(BSLParserENDPROCEDURE_KEYWORD)
	}

	return localctx
}

// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_function
	return p
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) FuncDeclaration() IFuncDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncDeclarationContext)
}

func (s *FunctionContext) SubCodeBlock() ISubCodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubCodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubCodeBlockContext)
}

func (s *FunctionContext) ENDFUNCTION_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDFUNCTION_KEYWORD, 0)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterFunction(s)
	}
}

func (s *FunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitFunction(s)
	}
}

func (p *BSLParser) Function() (localctx IFunctionContext) {
	this := p
	_ = this

	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, BSLParserRULE_function)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.FuncDeclaration()
	}
	{
		p.SetState(442)
		p.SubCodeBlock()
	}
	{
		p.SetState(443)
		p.Match(BSLParserENDFUNCTION_KEYWORD)
	}

	return localctx
}

// IProcDeclarationContext is an interface to support dynamic dispatch.
type IProcDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcDeclarationContext differentiates from other interfaces.
	IsProcDeclarationContext()
}

type ProcDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcDeclarationContext() *ProcDeclarationContext {
	var p = new(ProcDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_procDeclaration
	return p
}

func (*ProcDeclarationContext) IsProcDeclarationContext() {}

func NewProcDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcDeclarationContext {
	var p = new(ProcDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_procDeclaration

	return p
}

func (s *ProcDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcDeclarationContext) PROCEDURE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserPROCEDURE_KEYWORD, 0)
}

func (s *ProcDeclarationContext) SubName() ISubNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubNameContext)
}

func (s *ProcDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserLPAREN, 0)
}

func (s *ProcDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserRPAREN, 0)
}

func (s *ProcDeclarationContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *ProcDeclarationContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *ProcDeclarationContext) AllCompilerDirective() []ICompilerDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			len++
		}
	}

	tst := make([]ICompilerDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerDirectiveContext); ok {
			tst[i] = t.(ICompilerDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *ProcDeclarationContext) CompilerDirective(i int) ICompilerDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerDirectiveContext)
}

func (s *ProcDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ProcDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ProcDeclarationContext) ASYNC_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserASYNC_KEYWORD, 0)
}

func (s *ProcDeclarationContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *ProcDeclarationContext) EXPORT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserEXPORT_KEYWORD, 0)
}

func (s *ProcDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterProcDeclaration(s)
	}
}

func (s *ProcDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitProcDeclaration(s)
	}
}

func (p *BSLParser) ProcDeclaration() (localctx IProcDeclarationContext) {
	this := p
	_ = this

	localctx = NewProcDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, BSLParserRULE_procDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserAMPERSAND || _la == BSLParserHASH {
		p.SetState(448)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(445)
				p.Preprocessor()
			}

		case 2:
			{
				p.SetState(446)
				p.CompilerDirective()
			}

		case 3:
			{
				p.SetState(447)
				p.Annotation()
			}

		}

		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserASYNC_KEYWORD {
		{
			p.SetState(453)
			p.Match(BSLParserASYNC_KEYWORD)
		}

	}
	{
		p.SetState(456)
		p.Match(BSLParserPROCEDURE_KEYWORD)
	}
	{
		p.SetState(457)
		p.SubName()
	}
	{
		p.SetState(458)
		p.Match(BSLParserLPAREN)
	}
	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-23)) & ^0x3f) == 0 && ((int64(1)<<(_la-23))&9007199263129601) != 0 {
		{
			p.SetState(459)
			p.ParamList()
		}

	}
	{
		p.SetState(462)
		p.Match(BSLParserRPAREN)
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserEXPORT_KEYWORD {
		{
			p.SetState(463)
			p.Match(BSLParserEXPORT_KEYWORD)
		}

	}

	return localctx
}

// IFuncDeclarationContext is an interface to support dynamic dispatch.
type IFuncDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFuncDeclarationContext differentiates from other interfaces.
	IsFuncDeclarationContext()
}

type FuncDeclarationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncDeclarationContext() *FuncDeclarationContext {
	var p = new(FuncDeclarationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_funcDeclaration
	return p
}

func (*FuncDeclarationContext) IsFuncDeclarationContext() {}

func NewFuncDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncDeclarationContext {
	var p = new(FuncDeclarationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_funcDeclaration

	return p
}

func (s *FuncDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncDeclarationContext) FUNCTION_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserFUNCTION_KEYWORD, 0)
}

func (s *FuncDeclarationContext) SubName() ISubNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubNameContext)
}

func (s *FuncDeclarationContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserLPAREN, 0)
}

func (s *FuncDeclarationContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserRPAREN, 0)
}

func (s *FuncDeclarationContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *FuncDeclarationContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *FuncDeclarationContext) AllCompilerDirective() []ICompilerDirectiveContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			len++
		}
	}

	tst := make([]ICompilerDirectiveContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICompilerDirectiveContext); ok {
			tst[i] = t.(ICompilerDirectiveContext)
			i++
		}
	}

	return tst
}

func (s *FuncDeclarationContext) CompilerDirective(i int) ICompilerDirectiveContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilerDirectiveContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilerDirectiveContext)
}

func (s *FuncDeclarationContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *FuncDeclarationContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *FuncDeclarationContext) ASYNC_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserASYNC_KEYWORD, 0)
}

func (s *FuncDeclarationContext) ParamList() IParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *FuncDeclarationContext) EXPORT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserEXPORT_KEYWORD, 0)
}

func (s *FuncDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterFuncDeclaration(s)
	}
}

func (s *FuncDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitFuncDeclaration(s)
	}
}

func (p *BSLParser) FuncDeclaration() (localctx IFuncDeclarationContext) {
	this := p
	_ = this

	localctx = NewFuncDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, BSLParserRULE_funcDeclaration)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserAMPERSAND || _la == BSLParserHASH {
		p.SetState(469)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(466)
				p.Preprocessor()
			}

		case 2:
			{
				p.SetState(467)
				p.CompilerDirective()
			}

		case 3:
			{
				p.SetState(468)
				p.Annotation()
			}

		}

		p.SetState(473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserASYNC_KEYWORD {
		{
			p.SetState(474)
			p.Match(BSLParserASYNC_KEYWORD)
		}

	}
	{
		p.SetState(477)
		p.Match(BSLParserFUNCTION_KEYWORD)
	}
	{
		p.SetState(478)
		p.SubName()
	}
	{
		p.SetState(479)
		p.Match(BSLParserLPAREN)
	}
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-23)) & ^0x3f) == 0 && ((int64(1)<<(_la-23))&9007199263129601) != 0 {
		{
			p.SetState(480)
			p.ParamList()
		}

	}
	{
		p.SetState(483)
		p.Match(BSLParserRPAREN)
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserEXPORT_KEYWORD {
		{
			p.SetState(484)
			p.Match(BSLParserEXPORT_KEYWORD)
		}

	}

	return localctx
}

// ISubCodeBlockContext is an interface to support dynamic dispatch.
type ISubCodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubCodeBlockContext differentiates from other interfaces.
	IsSubCodeBlockContext()
}

type SubCodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubCodeBlockContext() *SubCodeBlockContext {
	var p = new(SubCodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_subCodeBlock
	return p
}

func (*SubCodeBlockContext) IsSubCodeBlockContext() {}

func NewSubCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubCodeBlockContext {
	var p = new(SubCodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_subCodeBlock

	return p
}

func (s *SubCodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *SubCodeBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *SubCodeBlockContext) SubVars() ISubVarsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubVarsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubVarsContext)
}

func (s *SubCodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubCodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubCodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterSubCodeBlock(s)
	}
}

func (s *SubCodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitSubCodeBlock(s)
	}
}

func (p *BSLParser) SubCodeBlock() (localctx ISubCodeBlockContext) {
	this := p
	_ = this

	localctx = NewSubCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, BSLParserRULE_subCodeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(487)
			p.SubVars()
		}

	}
	{
		p.SetState(490)
		p.CodeBlock()
	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserCONTINUE_KEYWORD, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (p *BSLParser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, BSLParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(492)
		p.Match(BSLParserCONTINUE_KEYWORD)
	}

	return localctx
}

// IBreakStatementContext is an interface to support dynamic dispatch.
type IBreakStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBreakStatementContext differentiates from other interfaces.
	IsBreakStatementContext()
}

type BreakStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBreakStatementContext() *BreakStatementContext {
	var p = new(BreakStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_breakStatement
	return p
}

func (*BreakStatementContext) IsBreakStatementContext() {}

func NewBreakStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BreakStatementContext {
	var p = new(BreakStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_breakStatement

	return p
}

func (s *BreakStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BreakStatementContext) BREAK_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserBREAK_KEYWORD, 0)
}

func (s *BreakStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BreakStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BreakStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterBreakStatement(s)
	}
}

func (s *BreakStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitBreakStatement(s)
	}
}

func (p *BSLParser) BreakStatement() (localctx IBreakStatementContext) {
	this := p
	_ = this

	localctx = NewBreakStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, BSLParserRULE_breakStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.Match(BSLParserBREAK_KEYWORD)
	}

	return localctx
}

// IRaiseStatementContext is an interface to support dynamic dispatch.
type IRaiseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaiseStatementContext differentiates from other interfaces.
	IsRaiseStatementContext()
}

type RaiseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaiseStatementContext() *RaiseStatementContext {
	var p = new(RaiseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_raiseStatement
	return p
}

func (*RaiseStatementContext) IsRaiseStatementContext() {}

func NewRaiseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RaiseStatementContext {
	var p = new(RaiseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_raiseStatement

	return p
}

func (s *RaiseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RaiseStatementContext) RAISE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserRAISE_KEYWORD, 0)
}

func (s *RaiseStatementContext) DoCall() IDoCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoCallContext)
}

func (s *RaiseStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *RaiseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RaiseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RaiseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterRaiseStatement(s)
	}
}

func (s *RaiseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitRaiseStatement(s)
	}
}

func (p *BSLParser) RaiseStatement() (localctx IRaiseStatementContext) {
	this := p
	_ = this

	localctx = NewRaiseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, BSLParserRULE_raiseStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(496)
		p.Match(BSLParserRAISE_KEYWORD)
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.SetState(498)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(497)
				p.Expression()
			}

		}

	case 2:
		{
			p.SetState(500)
			p.DoCall()
		}

	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IfBranch() IIfBranchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfBranchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfBranchContext)
}

func (s *IfStatementContext) ENDIF_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDIF_KEYWORD, 0)
}

func (s *IfStatementContext) AllElsifBranch() []IElsifBranchContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IElsifBranchContext); ok {
			len++
		}
	}

	tst := make([]IElsifBranchContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IElsifBranchContext); ok {
			tst[i] = t.(IElsifBranchContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) ElsifBranch(i int) IElsifBranchContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElsifBranchContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElsifBranchContext)
}

func (s *IfStatementContext) ElseBranch() IElseBranchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseBranchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseBranchContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (p *BSLParser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, BSLParserRULE_ifStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.IfBranch()
	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserELSIF_KEYWORD {
		{
			p.SetState(504)
			p.ElsifBranch()
		}

		p.SetState(509)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserELSE_KEYWORD {
		{
			p.SetState(510)
			p.ElseBranch()
		}

	}
	{
		p.SetState(513)
		p.Match(BSLParserENDIF_KEYWORD)
	}

	return localctx
}

// IIfBranchContext is an interface to support dynamic dispatch.
type IIfBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfBranchContext differentiates from other interfaces.
	IsIfBranchContext()
}

type IfBranchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfBranchContext() *IfBranchContext {
	var p = new(IfBranchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_ifBranch
	return p
}

func (*IfBranchContext) IsIfBranchContext() {}

func NewIfBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfBranchContext {
	var p = new(IfBranchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_ifBranch

	return p
}

func (s *IfBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *IfBranchContext) IF_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserIF_KEYWORD, 0)
}

func (s *IfBranchContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfBranchContext) THEN_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserTHEN_KEYWORD, 0)
}

func (s *IfBranchContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *IfBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterIfBranch(s)
	}
}

func (s *IfBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitIfBranch(s)
	}
}

func (p *BSLParser) IfBranch() (localctx IIfBranchContext) {
	this := p
	_ = this

	localctx = NewIfBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, BSLParserRULE_ifBranch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(515)
		p.Match(BSLParserIF_KEYWORD)
	}
	{
		p.SetState(516)
		p.Expression()
	}
	{
		p.SetState(517)
		p.Match(BSLParserTHEN_KEYWORD)
	}
	{
		p.SetState(518)
		p.CodeBlock()
	}

	return localctx
}

// IElsifBranchContext is an interface to support dynamic dispatch.
type IElsifBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElsifBranchContext differentiates from other interfaces.
	IsElsifBranchContext()
}

type ElsifBranchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElsifBranchContext() *ElsifBranchContext {
	var p = new(ElsifBranchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_elsifBranch
	return p
}

func (*ElsifBranchContext) IsElsifBranchContext() {}

func NewElsifBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElsifBranchContext {
	var p = new(ElsifBranchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_elsifBranch

	return p
}

func (s *ElsifBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *ElsifBranchContext) ELSIF_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserELSIF_KEYWORD, 0)
}

func (s *ElsifBranchContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ElsifBranchContext) THEN_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserTHEN_KEYWORD, 0)
}

func (s *ElsifBranchContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ElsifBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElsifBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElsifBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterElsifBranch(s)
	}
}

func (s *ElsifBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitElsifBranch(s)
	}
}

func (p *BSLParser) ElsifBranch() (localctx IElsifBranchContext) {
	this := p
	_ = this

	localctx = NewElsifBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, BSLParserRULE_elsifBranch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(520)
		p.Match(BSLParserELSIF_KEYWORD)
	}
	{
		p.SetState(521)
		p.Expression()
	}
	{
		p.SetState(522)
		p.Match(BSLParserTHEN_KEYWORD)
	}
	{
		p.SetState(523)
		p.CodeBlock()
	}

	return localctx
}

// IElseBranchContext is an interface to support dynamic dispatch.
type IElseBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElseBranchContext differentiates from other interfaces.
	IsElseBranchContext()
}

type ElseBranchContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseBranchContext() *ElseBranchContext {
	var p = new(ElseBranchContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_elseBranch
	return p
}

func (*ElseBranchContext) IsElseBranchContext() {}

func NewElseBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseBranchContext {
	var p = new(ElseBranchContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_elseBranch

	return p
}

func (s *ElseBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseBranchContext) ELSE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserELSE_KEYWORD, 0)
}

func (s *ElseBranchContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ElseBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterElseBranch(s)
	}
}

func (s *ElseBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitElseBranch(s)
	}
}

func (p *BSLParser) ElseBranch() (localctx IElseBranchContext) {
	this := p
	_ = this

	localctx = NewElseBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, BSLParserRULE_elseBranch)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(525)
		p.Match(BSLParserELSE_KEYWORD)
	}
	{
		p.SetState(526)
		p.CodeBlock()
	}

	return localctx
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_whileStatement
	return p
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) WHILE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserWHILE_KEYWORD, 0)
}

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) DO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserDO_KEYWORD, 0)
}

func (s *WhileStatementContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *WhileStatementContext) ENDDO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDDO_KEYWORD, 0)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (p *BSLParser) WhileStatement() (localctx IWhileStatementContext) {
	this := p
	_ = this

	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, BSLParserRULE_whileStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(528)
		p.Match(BSLParserWHILE_KEYWORD)
	}
	{
		p.SetState(529)
		p.Expression()
	}
	{
		p.SetState(530)
		p.Match(BSLParserDO_KEYWORD)
	}
	{
		p.SetState(531)
		p.CodeBlock()
	}
	{
		p.SetState(532)
		p.Match(BSLParserENDDO_KEYWORD)
	}

	return localctx
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_forStatement
	return p
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) FOR_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserFOR_KEYWORD, 0)
}

func (s *ForStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *ForStatementContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(BSLParserASSIGN, 0)
}

func (s *ForStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ForStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) TO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserTO_KEYWORD, 0)
}

func (s *ForStatementContext) DO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserDO_KEYWORD, 0)
}

func (s *ForStatementContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ForStatementContext) ENDDO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDDO_KEYWORD, 0)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (p *BSLParser) ForStatement() (localctx IForStatementContext) {
	this := p
	_ = this

	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, BSLParserRULE_forStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(534)
		p.Match(BSLParserFOR_KEYWORD)
	}
	{
		p.SetState(535)
		p.Match(BSLParserIDENTIFIER)
	}
	{
		p.SetState(536)
		p.Match(BSLParserASSIGN)
	}
	{
		p.SetState(537)
		p.Expression()
	}
	{
		p.SetState(538)
		p.Match(BSLParserTO_KEYWORD)
	}
	{
		p.SetState(539)
		p.Expression()
	}
	{
		p.SetState(540)
		p.Match(BSLParserDO_KEYWORD)
	}
	{
		p.SetState(541)
		p.CodeBlock()
	}
	{
		p.SetState(542)
		p.Match(BSLParserENDDO_KEYWORD)
	}

	return localctx
}

// IForEachStatementContext is an interface to support dynamic dispatch.
type IForEachStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForEachStatementContext differentiates from other interfaces.
	IsForEachStatementContext()
}

type ForEachStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForEachStatementContext() *ForEachStatementContext {
	var p = new(ForEachStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_forEachStatement
	return p
}

func (*ForEachStatementContext) IsForEachStatementContext() {}

func NewForEachStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForEachStatementContext {
	var p = new(ForEachStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_forEachStatement

	return p
}

func (s *ForEachStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForEachStatementContext) FOR_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserFOR_KEYWORD, 0)
}

func (s *ForEachStatementContext) EACH_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserEACH_KEYWORD, 0)
}

func (s *ForEachStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *ForEachStatementContext) IN_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserIN_KEYWORD, 0)
}

func (s *ForEachStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForEachStatementContext) DO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserDO_KEYWORD, 0)
}

func (s *ForEachStatementContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ForEachStatementContext) ENDDO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDDO_KEYWORD, 0)
}

func (s *ForEachStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForEachStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForEachStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterForEachStatement(s)
	}
}

func (s *ForEachStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitForEachStatement(s)
	}
}

func (p *BSLParser) ForEachStatement() (localctx IForEachStatementContext) {
	this := p
	_ = this

	localctx = NewForEachStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, BSLParserRULE_forEachStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(544)
		p.Match(BSLParserFOR_KEYWORD)
	}
	{
		p.SetState(545)
		p.Match(BSLParserEACH_KEYWORD)
	}
	{
		p.SetState(546)
		p.Match(BSLParserIDENTIFIER)
	}
	{
		p.SetState(547)
		p.Match(BSLParserIN_KEYWORD)
	}
	{
		p.SetState(548)
		p.Expression()
	}
	{
		p.SetState(549)
		p.Match(BSLParserDO_KEYWORD)
	}
	{
		p.SetState(550)
		p.CodeBlock()
	}
	{
		p.SetState(551)
		p.Match(BSLParserENDDO_KEYWORD)
	}

	return localctx
}

// ITryStatementContext is an interface to support dynamic dispatch.
type ITryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryStatementContext differentiates from other interfaces.
	IsTryStatementContext()
}

type TryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryStatementContext() *TryStatementContext {
	var p = new(TryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_tryStatement
	return p
}

func (*TryStatementContext) IsTryStatementContext() {}

func NewTryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryStatementContext {
	var p = new(TryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_tryStatement

	return p
}

func (s *TryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TryStatementContext) TRY_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserTRY_KEYWORD, 0)
}

func (s *TryStatementContext) TryCodeBlock() ITryCodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryCodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryCodeBlockContext)
}

func (s *TryStatementContext) EXCEPT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserEXCEPT_KEYWORD, 0)
}

func (s *TryStatementContext) ExceptCodeBlock() IExceptCodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptCodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptCodeBlockContext)
}

func (s *TryStatementContext) ENDTRY_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserENDTRY_KEYWORD, 0)
}

func (s *TryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterTryStatement(s)
	}
}

func (s *TryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitTryStatement(s)
	}
}

func (p *BSLParser) TryStatement() (localctx ITryStatementContext) {
	this := p
	_ = this

	localctx = NewTryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, BSLParserRULE_tryStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(BSLParserTRY_KEYWORD)
	}
	{
		p.SetState(554)
		p.TryCodeBlock()
	}
	{
		p.SetState(555)
		p.Match(BSLParserEXCEPT_KEYWORD)
	}
	{
		p.SetState(556)
		p.ExceptCodeBlock()
	}
	{
		p.SetState(557)
		p.Match(BSLParserENDTRY_KEYWORD)
	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserRETURN_KEYWORD, 0)
}

func (s *ReturnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (p *BSLParser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, BSLParserRULE_returnStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(559)
		p.Match(BSLParserRETURN_KEYWORD)
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(560)
			p.Expression()
		}

	}

	return localctx
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_executeStatement
	return p
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserEXECUTE_KEYWORD, 0)
}

func (s *ExecuteStatementContext) DoCall() IDoCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoCallContext)
}

func (s *ExecuteStatementContext) CallParamList() ICallParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallParamListContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (p *BSLParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	this := p
	_ = this

	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, BSLParserRULE_executeStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(563)
		p.Match(BSLParserEXECUTE_KEYWORD)
	}
	p.SetState(566)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(564)
			p.DoCall()
		}

	case 2:
		{
			p.SetState(565)
			p.CallParamList()
		}

	}

	return localctx
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_callStatement
	return p
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) AccessCall() IAccessCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessCallContext)
}

func (s *CallStatementContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *CallStatementContext) GlobalMethodCall() IGlobalMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalMethodCallContext)
}

func (s *CallStatementContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *CallStatementContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (p *BSLParser) CallStatement() (localctx ICallStatementContext) {
	this := p
	_ = this

	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, BSLParserRULE_callStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(568)
				p.Match(BSLParserIDENTIFIER)
			}

		case 2:
			{
				p.SetState(569)
				p.GlobalMethodCall()
			}

		}
		p.SetState(575)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(572)
					p.Modifier()
				}

			}
			p.SetState(577)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext())
		}
		{
			p.SetState(578)
			p.AccessCall()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(579)
			p.GlobalMethodCall()
		}

	}

	return localctx
}

// IWaitStatementContext is an interface to support dynamic dispatch.
type IWaitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaitStatementContext differentiates from other interfaces.
	IsWaitStatementContext()
}

type WaitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitStatementContext() *WaitStatementContext {
	var p = new(WaitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_waitStatement
	return p
}

func (*WaitStatementContext) IsWaitStatementContext() {}

func NewWaitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitStatementContext {
	var p = new(WaitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_waitStatement

	return p
}

func (s *WaitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitStatementContext) WaitExpression() IWaitExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitExpressionContext)
}

func (s *WaitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterWaitStatement(s)
	}
}

func (s *WaitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitWaitStatement(s)
	}
}

func (p *BSLParser) WaitStatement() (localctx IWaitStatementContext) {
	this := p
	_ = this

	localctx = NewWaitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, BSLParserRULE_waitStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(582)
		p.WaitExpression()
	}

	return localctx
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_labelName
	return p
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (p *BSLParser) LabelName() (localctx ILabelNameContext) {
	this := p
	_ = this

	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, BSLParserRULE_labelName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(584)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// ILabelContext is an interface to support dynamic dispatch.
type ILabelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelContext differentiates from other interfaces.
	IsLabelContext()
}

type LabelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelContext() *LabelContext {
	var p = new(LabelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_label
	return p
}

func (*LabelContext) IsLabelContext() {}

func NewLabelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelContext {
	var p = new(LabelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_label

	return p
}

func (s *LabelContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelContext) TILDA() antlr.TerminalNode {
	return s.GetToken(BSLParserTILDA, 0)
}

func (s *LabelContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LabelContext) COLON() antlr.TerminalNode {
	return s.GetToken(BSLParserCOLON, 0)
}

func (s *LabelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterLabel(s)
	}
}

func (s *LabelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitLabel(s)
	}
}

func (p *BSLParser) Label() (localctx ILabelContext) {
	this := p
	_ = this

	localctx = NewLabelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, BSLParserRULE_label)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(586)
		p.Match(BSLParserTILDA)
	}
	{
		p.SetState(587)
		p.LabelName()
	}
	{
		p.SetState(588)
		p.Match(BSLParserCOLON)
	}

	return localctx
}

// IGotoStatementContext is an interface to support dynamic dispatch.
type IGotoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGotoStatementContext differentiates from other interfaces.
	IsGotoStatementContext()
}

type GotoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGotoStatementContext() *GotoStatementContext {
	var p = new(GotoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_gotoStatement
	return p
}

func (*GotoStatementContext) IsGotoStatementContext() {}

func NewGotoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GotoStatementContext {
	var p = new(GotoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_gotoStatement

	return p
}

func (s *GotoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GotoStatementContext) GOTO_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserGOTO_KEYWORD, 0)
}

func (s *GotoStatementContext) TILDA() antlr.TerminalNode {
	return s.GetToken(BSLParserTILDA, 0)
}

func (s *GotoStatementContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *GotoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GotoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GotoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterGotoStatement(s)
	}
}

func (s *GotoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitGotoStatement(s)
	}
}

func (p *BSLParser) GotoStatement() (localctx IGotoStatementContext) {
	this := p
	_ = this

	localctx = NewGotoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, BSLParserRULE_gotoStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Match(BSLParserGOTO_KEYWORD)
	}
	{
		p.SetState(591)
		p.Match(BSLParserTILDA)
	}
	{
		p.SetState(592)
		p.LabelName()
	}

	return localctx
}

// ITryCodeBlockContext is an interface to support dynamic dispatch.
type ITryCodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTryCodeBlockContext differentiates from other interfaces.
	IsTryCodeBlockContext()
}

type TryCodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryCodeBlockContext() *TryCodeBlockContext {
	var p = new(TryCodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_tryCodeBlock
	return p
}

func (*TryCodeBlockContext) IsTryCodeBlockContext() {}

func NewTryCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryCodeBlockContext {
	var p = new(TryCodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_tryCodeBlock

	return p
}

func (s *TryCodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *TryCodeBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *TryCodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryCodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryCodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterTryCodeBlock(s)
	}
}

func (s *TryCodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitTryCodeBlock(s)
	}
}

func (p *BSLParser) TryCodeBlock() (localctx ITryCodeBlockContext) {
	this := p
	_ = this

	localctx = NewTryCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, BSLParserRULE_tryCodeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(594)
		p.CodeBlock()
	}

	return localctx
}

// IExceptCodeBlockContext is an interface to support dynamic dispatch.
type IExceptCodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptCodeBlockContext differentiates from other interfaces.
	IsExceptCodeBlockContext()
}

type ExceptCodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptCodeBlockContext() *ExceptCodeBlockContext {
	var p = new(ExceptCodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_exceptCodeBlock
	return p
}

func (*ExceptCodeBlockContext) IsExceptCodeBlockContext() {}

func NewExceptCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptCodeBlockContext {
	var p = new(ExceptCodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_exceptCodeBlock

	return p
}

func (s *ExceptCodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptCodeBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *ExceptCodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptCodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptCodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterExceptCodeBlock(s)
	}
}

func (s *ExceptCodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitExceptCodeBlock(s)
	}
}

func (p *BSLParser) ExceptCodeBlock() (localctx IExceptCodeBlockContext) {
	this := p
	_ = this

	localctx = NewExceptCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, BSLParserRULE_exceptCodeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.CodeBlock()
	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *BSLParser) Event() (localctx IEventContext) {
	this := p
	_ = this

	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, BSLParserRULE_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(598)
		p.Expression()
	}

	return localctx
}

// IHandlerContext is an interface to support dynamic dispatch.
type IHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHandlerContext differentiates from other interfaces.
	IsHandlerContext()
}

type HandlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerContext() *HandlerContext {
	var p = new(HandlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_handler
	return p
}

func (*HandlerContext) IsHandlerContext() {}

func NewHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerContext {
	var p = new(HandlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_handler

	return p
}

func (s *HandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *HandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterHandler(s)
	}
}

func (s *HandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitHandler(s)
	}
}

func (p *BSLParser) Handler() (localctx IHandlerContext) {
	this := p
	_ = this

	localctx = NewHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, BSLParserRULE_handler)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(600)
		p.Expression()
	}

	return localctx
}

// IAddHandlerStatementContext is an interface to support dynamic dispatch.
type IAddHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddHandlerStatementContext differentiates from other interfaces.
	IsAddHandlerStatementContext()
}

type AddHandlerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddHandlerStatementContext() *AddHandlerStatementContext {
	var p = new(AddHandlerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_addHandlerStatement
	return p
}

func (*AddHandlerStatementContext) IsAddHandlerStatementContext() {}

func NewAddHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddHandlerStatementContext {
	var p = new(AddHandlerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_addHandlerStatement

	return p
}

func (s *AddHandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddHandlerStatementContext) ADDHANDLER_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserADDHANDLER_KEYWORD, 0)
}

func (s *AddHandlerStatementContext) Event() IEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *AddHandlerStatementContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, 0)
}

func (s *AddHandlerStatementContext) Handler() IHandlerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerContext)
}

func (s *AddHandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddHandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddHandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAddHandlerStatement(s)
	}
}

func (s *AddHandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAddHandlerStatement(s)
	}
}

func (p *BSLParser) AddHandlerStatement() (localctx IAddHandlerStatementContext) {
	this := p
	_ = this

	localctx = NewAddHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, BSLParserRULE_addHandlerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(602)
		p.Match(BSLParserADDHANDLER_KEYWORD)
	}
	{
		p.SetState(603)
		p.Event()
	}
	{
		p.SetState(604)
		p.Match(BSLParserCOMMA)
	}
	{
		p.SetState(605)
		p.Handler()
	}

	return localctx
}

// IRemoveHandlerStatementContext is an interface to support dynamic dispatch.
type IRemoveHandlerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemoveHandlerStatementContext differentiates from other interfaces.
	IsRemoveHandlerStatementContext()
}

type RemoveHandlerStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemoveHandlerStatementContext() *RemoveHandlerStatementContext {
	var p = new(RemoveHandlerStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_removeHandlerStatement
	return p
}

func (*RemoveHandlerStatementContext) IsRemoveHandlerStatementContext() {}

func NewRemoveHandlerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemoveHandlerStatementContext {
	var p = new(RemoveHandlerStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_removeHandlerStatement

	return p
}

func (s *RemoveHandlerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RemoveHandlerStatementContext) REMOVEHANDLER_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserREMOVEHANDLER_KEYWORD, 0)
}

func (s *RemoveHandlerStatementContext) Event() IEventContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *RemoveHandlerStatementContext) COMMA() antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, 0)
}

func (s *RemoveHandlerStatementContext) Handler() IHandlerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerContext)
}

func (s *RemoveHandlerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemoveHandlerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemoveHandlerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterRemoveHandlerStatement(s)
	}
}

func (s *RemoveHandlerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitRemoveHandlerStatement(s)
	}
}

func (p *BSLParser) RemoveHandlerStatement() (localctx IRemoveHandlerStatementContext) {
	this := p
	_ = this

	localctx = NewRemoveHandlerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, BSLParserRULE_removeHandlerStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(BSLParserREMOVEHANDLER_KEYWORD)
	}
	{
		p.SetState(608)
		p.Event()
	}
	{
		p.SetState(609)
		p.Match(BSLParserCOMMA)
	}
	{
		p.SetState(610)
		p.Handler()
	}

	return localctx
}

// ITernaryOperatorContext is an interface to support dynamic dispatch.
type ITernaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTernaryOperatorContext differentiates from other interfaces.
	IsTernaryOperatorContext()
}

type TernaryOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTernaryOperatorContext() *TernaryOperatorContext {
	var p = new(TernaryOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_ternaryOperator
	return p
}

func (*TernaryOperatorContext) IsTernaryOperatorContext() {}

func NewTernaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryOperatorContext {
	var p = new(TernaryOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_ternaryOperator

	return p
}

func (s *TernaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryOperatorContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(BSLParserQUESTION, 0)
}

func (s *TernaryOperatorContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserLPAREN, 0)
}

func (s *TernaryOperatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TernaryOperatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TernaryOperatorContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BSLParserCOMMA)
}

func (s *TernaryOperatorContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, i)
}

func (s *TernaryOperatorContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserRPAREN, 0)
}

func (s *TernaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterTernaryOperator(s)
	}
}

func (s *TernaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitTernaryOperator(s)
	}
}

func (p *BSLParser) TernaryOperator() (localctx ITernaryOperatorContext) {
	this := p
	_ = this

	localctx = NewTernaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, BSLParserRULE_ternaryOperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(612)
		p.Match(BSLParserQUESTION)
	}
	{
		p.SetState(613)
		p.Match(BSLParserLPAREN)
	}
	{
		p.SetState(614)
		p.Expression()
	}
	{
		p.SetState(615)
		p.Match(BSLParserCOMMA)
	}
	{
		p.SetState(616)
		p.Expression()
	}
	{
		p.SetState(617)
		p.Match(BSLParserCOMMA)
	}
	{
		p.SetState(618)
		p.Expression()
	}
	{
		p.SetState(619)
		p.Match(BSLParserRPAREN)
	}

	return localctx
}

// IWaitExpressionContext is an interface to support dynamic dispatch.
type IWaitExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWaitExpressionContext differentiates from other interfaces.
	IsWaitExpressionContext()
}

type WaitExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWaitExpressionContext() *WaitExpressionContext {
	var p = new(WaitExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_waitExpression
	return p
}

func (*WaitExpressionContext) IsWaitExpressionContext() {}

func NewWaitExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WaitExpressionContext {
	var p = new(WaitExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_waitExpression

	return p
}

func (s *WaitExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WaitExpressionContext) AWAIT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserAWAIT_KEYWORD, 0)
}

func (s *WaitExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WaitExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WaitExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WaitExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterWaitExpression(s)
	}
}

func (s *WaitExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitWaitExpression(s)
	}
}

func (p *BSLParser) WaitExpression() (localctx IWaitExpressionContext) {
	this := p
	_ = this

	localctx = NewWaitExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, BSLParserRULE_waitExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(621)
		p.Match(BSLParserAWAIT_KEYWORD)
	}
	{
		p.SetState(622)
		p.Expression()
	}

	return localctx
}

// IFileCodeBlockBeforeSubContext is an interface to support dynamic dispatch.
type IFileCodeBlockBeforeSubContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileCodeBlockBeforeSubContext differentiates from other interfaces.
	IsFileCodeBlockBeforeSubContext()
}

type FileCodeBlockBeforeSubContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileCodeBlockBeforeSubContext() *FileCodeBlockBeforeSubContext {
	var p = new(FileCodeBlockBeforeSubContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_fileCodeBlockBeforeSub
	return p
}

func (*FileCodeBlockBeforeSubContext) IsFileCodeBlockBeforeSubContext() {}

func NewFileCodeBlockBeforeSubContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileCodeBlockBeforeSubContext {
	var p = new(FileCodeBlockBeforeSubContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_fileCodeBlockBeforeSub

	return p
}

func (s *FileCodeBlockBeforeSubContext) GetParser() antlr.Parser { return s.parser }

func (s *FileCodeBlockBeforeSubContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FileCodeBlockBeforeSubContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileCodeBlockBeforeSubContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileCodeBlockBeforeSubContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterFileCodeBlockBeforeSub(s)
	}
}

func (s *FileCodeBlockBeforeSubContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitFileCodeBlockBeforeSub(s)
	}
}

func (p *BSLParser) FileCodeBlockBeforeSub() (localctx IFileCodeBlockBeforeSubContext) {
	this := p
	_ = this

	localctx = NewFileCodeBlockBeforeSubContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, BSLParserRULE_fileCodeBlockBeforeSub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(624)
		p.CodeBlock()
	}

	return localctx
}

// IFileCodeBlockContext is an interface to support dynamic dispatch.
type IFileCodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileCodeBlockContext differentiates from other interfaces.
	IsFileCodeBlockContext()
}

type FileCodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileCodeBlockContext() *FileCodeBlockContext {
	var p = new(FileCodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_fileCodeBlock
	return p
}

func (*FileCodeBlockContext) IsFileCodeBlockContext() {}

func NewFileCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileCodeBlockContext {
	var p = new(FileCodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_fileCodeBlock

	return p
}

func (s *FileCodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FileCodeBlockContext) CodeBlock() ICodeBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeBlockContext)
}

func (s *FileCodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileCodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileCodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterFileCodeBlock(s)
	}
}

func (s *FileCodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitFileCodeBlock(s)
	}
}

func (p *BSLParser) FileCodeBlock() (localctx IFileCodeBlockContext) {
	this := p
	_ = this

	localctx = NewFileCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, BSLParserRULE_fileCodeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(626)
		p.CodeBlock()
	}

	return localctx
}

// ICodeBlockContext is an interface to support dynamic dispatch.
type ICodeBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeBlockContext differentiates from other interfaces.
	IsCodeBlockContext()
}

type CodeBlockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeBlockContext() *CodeBlockContext {
	var p = new(CodeBlockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_codeBlock
	return p
}

func (*CodeBlockContext) IsCodeBlockContext() {}

func NewCodeBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeBlockContext {
	var p = new(CodeBlockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_codeBlock

	return p
}

func (s *CodeBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeBlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *CodeBlockContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *CodeBlockContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *CodeBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCodeBlock(s)
	}
}

func (s *CodeBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCodeBlock(s)
	}
}

func (p *BSLParser) CodeBlock() (localctx ICodeBlockContext) {
	this := p
	_ = this

	localctx = NewCodeBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, BSLParserRULE_codeBlock)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(630)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(628)
					p.Statement()
				}

			case 2:
				{
					p.SetState(629)
					p.Preprocessor()
				}

			}

		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext())
	}

	return localctx
}

// INumericContext is an interface to support dynamic dispatch.
type INumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericContext differentiates from other interfaces.
	IsNumericContext()
}

type NumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericContext() *NumericContext {
	var p = new(NumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_numeric
	return p
}

func (*NumericContext) IsNumericContext() {}

func NewNumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericContext {
	var p = new(NumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_numeric

	return p
}

func (s *NumericContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(BSLParserFLOAT, 0)
}

func (s *NumericContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(BSLParserDECIMAL, 0)
}

func (s *NumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterNumeric(s)
	}
}

func (s *NumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitNumeric(s)
	}
}

func (p *BSLParser) Numeric() (localctx INumericContext) {
	this := p
	_ = this

	localctx = NewNumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, BSLParserRULE_numeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(635)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BSLParserDECIMAL || _la == BSLParserFLOAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_paramList
	return p
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllParam() []IParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParamContext); ok {
			len++
		}
	}

	tst := make([]IParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParamContext); ok {
			tst[i] = t.(IParamContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Param(i int) IParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParamListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BSLParserCOMMA)
}

func (s *ParamListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, i)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterParamList(s)
	}
}

func (s *ParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitParamList(s)
	}
}

func (p *BSLParser) ParamList() (localctx IParamListContext) {
	this := p
	_ = this

	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, BSLParserRULE_paramList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(637)
		p.Param()
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserCOMMA {
		{
			p.SetState(638)
			p.Match(BSLParserCOMMA)
		}
		{
			p.SetState(639)
			p.Param()
		}

		p.SetState(644)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *ParamContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *ParamContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *ParamContext) VAL_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserVAL_KEYWORD, 0)
}

func (s *ParamContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(BSLParserASSIGN, 0)
}

func (s *ParamContext) DefaultValue() IDefaultValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultValueContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *BSLParser) Param() (localctx IParamContext) {
	this := p
	_ = this

	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, BSLParserRULE_param)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserAMPERSAND {
		{
			p.SetState(645)
			p.Annotation()
		}

		p.SetState(650)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserVAL_KEYWORD {
		{
			p.SetState(651)
			p.Match(BSLParserVAL_KEYWORD)
		}

	}
	{
		p.SetState(654)
		p.Match(BSLParserIDENTIFIER)
	}
	p.SetState(657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserASSIGN {
		{
			p.SetState(655)
			p.Match(BSLParserASSIGN)
		}
		{
			p.SetState(656)
			p.DefaultValue()
		}

	}

	return localctx
}

// IDefaultValueContext is an interface to support dynamic dispatch.
type IDefaultValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultValueContext differentiates from other interfaces.
	IsDefaultValueContext()
}

type DefaultValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultValueContext() *DefaultValueContext {
	var p = new(DefaultValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_defaultValue
	return p
}

func (*DefaultValueContext) IsDefaultValueContext() {}

func NewDefaultValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultValueContext {
	var p = new(DefaultValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_defaultValue

	return p
}

func (s *DefaultValueContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultValueContext) ConstValue() IConstValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *DefaultValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterDefaultValue(s)
	}
}

func (s *DefaultValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitDefaultValue(s)
	}
}

func (p *BSLParser) DefaultValue() (localctx IDefaultValueContext) {
	this := p
	_ = this

	localctx = NewDefaultValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, BSLParserRULE_defaultValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.ConstValue()
	}

	return localctx
}

// IConstValueContext is an interface to support dynamic dispatch.
type IConstValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstValueContext differentiates from other interfaces.
	IsConstValueContext()
}

type ConstValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstValueContext() *ConstValueContext {
	var p = new(ConstValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_constValue
	return p
}

func (*ConstValueContext) IsConstValueContext() {}

func NewConstValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstValueContext {
	var p = new(ConstValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_constValue

	return p
}

func (s *ConstValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstValueContext) Numeric() INumericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericContext)
}

func (s *ConstValueContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BSLParserMINUS, 0)
}

func (s *ConstValueContext) PLUS() antlr.TerminalNode {
	return s.GetToken(BSLParserPLUS, 0)
}

func (s *ConstValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ConstValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(BSLParserTRUE, 0)
}

func (s *ConstValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(BSLParserFALSE, 0)
}

func (s *ConstValueContext) UNDEFINED() antlr.TerminalNode {
	return s.GetToken(BSLParserUNDEFINED, 0)
}

func (s *ConstValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(BSLParserNULL, 0)
}

func (s *ConstValueContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(BSLParserDATETIME, 0)
}

func (s *ConstValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterConstValue(s)
	}
}

func (s *ConstValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitConstValue(s)
	}
}

func (p *BSLParser) ConstValue() (localctx IConstValueContext) {
	this := p
	_ = this

	localctx = NewConstValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, BSLParserRULE_constValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(671)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserPLUS, BSLParserMINUS, BSLParserDECIMAL, BSLParserFLOAT:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == BSLParserPLUS || _la == BSLParserMINUS {
			{
				p.SetState(661)
				_la = p.GetTokenStream().LA(1)

				if !(_la == BSLParserPLUS || _la == BSLParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(664)
			p.Numeric()
		}

	case BSLParserSTRING, BSLParserSTRINGSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(665)
			p.String_()
		}

	case BSLParserTRUE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(666)
			p.Match(BSLParserTRUE)
		}

	case BSLParserFALSE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(667)
			p.Match(BSLParserFALSE)
		}

	case BSLParserUNDEFINED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(668)
			p.Match(BSLParserUNDEFINED)
		}

	case BSLParserNULL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(669)
			p.Match(BSLParserNULL)
		}

	case BSLParserDATETIME:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(670)
			p.Match(BSLParserDATETIME)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMultilineStringContext is an interface to support dynamic dispatch.
type IMultilineStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultilineStringContext differentiates from other interfaces.
	IsMultilineStringContext()
}

type MultilineStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultilineStringContext() *MultilineStringContext {
	var p = new(MultilineStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_multilineString
	return p
}

func (*MultilineStringContext) IsMultilineStringContext() {}

func NewMultilineStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultilineStringContext {
	var p = new(MultilineStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_multilineString

	return p
}

func (s *MultilineStringContext) GetParser() antlr.Parser { return s.parser }

func (s *MultilineStringContext) STRINGSTART() antlr.TerminalNode {
	return s.GetToken(BSLParserSTRINGSTART, 0)
}

func (s *MultilineStringContext) STRINGTAIL() antlr.TerminalNode {
	return s.GetToken(BSLParserSTRINGTAIL, 0)
}

func (s *MultilineStringContext) AllSTRINGPART() []antlr.TerminalNode {
	return s.GetTokens(BSLParserSTRINGPART)
}

func (s *MultilineStringContext) STRINGPART(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserSTRINGPART, i)
}

func (s *MultilineStringContext) AllBAR() []antlr.TerminalNode {
	return s.GetTokens(BSLParserBAR)
}

func (s *MultilineStringContext) BAR(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserBAR, i)
}

func (s *MultilineStringContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *MultilineStringContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *MultilineStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultilineStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultilineStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterMultilineString(s)
	}
}

func (s *MultilineStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitMultilineString(s)
	}
}

func (p *BSLParser) MultilineString() (localctx IMultilineStringContext) {
	this := p
	_ = this

	localctx = NewMultilineStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, BSLParserRULE_multilineString)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(673)
		p.Match(BSLParserSTRINGSTART)
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1099914280960) != 0 {
		p.SetState(677)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case BSLParserSTRINGPART:
			{
				p.SetState(674)
				p.Match(BSLParserSTRINGPART)
			}

		case BSLParserBAR:
			{
				p.SetState(675)
				p.Match(BSLParserBAR)
			}

		case BSLParserHASH:
			{
				p.SetState(676)
				p.Preprocessor()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(681)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(682)
		p.Match(BSLParserSTRINGTAIL)
	}

	return localctx
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_string
	return p
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(BSLParserSTRING)
}

func (s *StringContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserSTRING, i)
}

func (s *StringContext) AllMultilineString() []IMultilineStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultilineStringContext); ok {
			len++
		}
	}

	tst := make([]IMultilineStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultilineStringContext); ok {
			tst[i] = t.(IMultilineStringContext)
			i++
		}
	}

	return tst
}

func (s *StringContext) MultilineString(i int) IMultilineStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultilineStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultilineStringContext)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitString(s)
	}
}

func (p *BSLParser) String_() (localctx IStringContext) {
	this := p
	_ = this

	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, BSLParserRULE_string)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == BSLParserSTRING || _la == BSLParserSTRINGSTART {
		p.SetState(686)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case BSLParserSTRING:
			{
				p.SetState(684)
				p.Match(BSLParserSTRING)
			}

		case BSLParserSTRINGSTART:
			{
				p.SetState(685)
				p.MultilineString()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(688)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(BSLParserSEMICOLON, 0)
}

func (s *StatementContext) Label() ILabelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelContext)
}

func (s *StatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *StatementContext) WaitStatement() IWaitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitStatementContext)
}

func (s *StatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StatementContext) Assignment() IAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *StatementContext) Preprocessor() IPreprocessorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *BSLParser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, BSLParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(711)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserHASH, BSLParserTILDA, BSLParserIF_KEYWORD, BSLParserWHILE_KEYWORD, BSLParserFOR_KEYWORD, BSLParserTRY_KEYWORD, BSLParserRETURN_KEYWORD, BSLParserCONTINUE_KEYWORD, BSLParserRAISE_KEYWORD, BSLParserGOTO_KEYWORD, BSLParserBREAK_KEYWORD, BSLParserEXECUTE_KEYWORD, BSLParserADDHANDLER_KEYWORD, BSLParserREMOVEHANDLER_KEYWORD, BSLParserIDENTIFIER, BSLParserAWAIT_KEYWORD:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(705)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case BSLParserTILDA:
			{
				p.SetState(690)
				p.Label()
			}
			p.SetState(696)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(691)
					p.CallStatement()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(692)
					p.WaitStatement()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 3 {
				{
					p.SetState(693)
					p.CompoundStatement()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 4 {
				{
					p.SetState(694)
					p.Assignment()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) == 5 {
				{
					p.SetState(695)
					p.Preprocessor()
				}

			}

		case BSLParserHASH, BSLParserIF_KEYWORD, BSLParserWHILE_KEYWORD, BSLParserFOR_KEYWORD, BSLParserTRY_KEYWORD, BSLParserRETURN_KEYWORD, BSLParserCONTINUE_KEYWORD, BSLParserRAISE_KEYWORD, BSLParserGOTO_KEYWORD, BSLParserBREAK_KEYWORD, BSLParserEXECUTE_KEYWORD, BSLParserADDHANDLER_KEYWORD, BSLParserREMOVEHANDLER_KEYWORD, BSLParserIDENTIFIER, BSLParserAWAIT_KEYWORD:
			p.SetState(703)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(698)
					p.CallStatement()
				}

			case 2:
				{
					p.SetState(699)
					p.WaitStatement()
				}

			case 3:
				{
					p.SetState(700)
					p.CompoundStatement()
				}

			case 4:
				{
					p.SetState(701)
					p.Assignment()
				}

			case 5:
				{
					p.SetState(702)
					p.Preprocessor()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(707)
				p.Match(BSLParserSEMICOLON)
			}

		}

	case BSLParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(710)
			p.Match(BSLParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_assignment
	return p
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) LValue() ILValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILValueContext)
}

func (s *AssignmentContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(BSLParserASSIGN, 0)
}

func (s *AssignmentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AssignmentContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *BSLParser) Assignment() (localctx IAssignmentContext) {
	this := p
	_ = this

	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, BSLParserRULE_assignment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(713)
		p.LValue()
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserHASH {
		{
			p.SetState(714)
			p.Preprocessor()
		}

		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(720)
		p.Match(BSLParserASSIGN)
	}

	p.SetState(724)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserHASH {
		{
			p.SetState(721)
			p.Preprocessor()
		}

		p.SetState(726)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(727)
		p.Expression()
	}

	return localctx
}

// ICallParamListContext is an interface to support dynamic dispatch.
type ICallParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallParamListContext differentiates from other interfaces.
	IsCallParamListContext()
}

type CallParamListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallParamListContext() *CallParamListContext {
	var p = new(CallParamListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_callParamList
	return p
}

func (*CallParamListContext) IsCallParamListContext() {}

func NewCallParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallParamListContext {
	var p = new(CallParamListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_callParamList

	return p
}

func (s *CallParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *CallParamListContext) AllCallParam() []ICallParamContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallParamContext); ok {
			len++
		}
	}

	tst := make([]ICallParamContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallParamContext); ok {
			tst[i] = t.(ICallParamContext)
			i++
		}
	}

	return tst
}

func (s *CallParamListContext) CallParam(i int) ICallParamContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallParamContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallParamContext)
}

func (s *CallParamListContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(BSLParserCOMMA)
}

func (s *CallParamListContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(BSLParserCOMMA, i)
}

func (s *CallParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallParamListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCallParamList(s)
	}
}

func (s *CallParamListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCallParamList(s)
	}
}

func (p *BSLParser) CallParamList() (localctx ICallParamListContext) {
	this := p
	_ = this

	localctx = NewCallParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, BSLParserRULE_callParamList)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(729)
		p.CallParam()
	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserCOMMA {
		{
			p.SetState(730)
			p.Match(BSLParserCOMMA)
		}
		{
			p.SetState(731)
			p.CallParam()
		}

		p.SetState(736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICallParamContext is an interface to support dynamic dispatch.
type ICallParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallParamContext differentiates from other interfaces.
	IsCallParamContext()
}

type CallParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallParamContext() *CallParamContext {
	var p = new(CallParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_callParam
	return p
}

func (*CallParamContext) IsCallParamContext() {}

func NewCallParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallParamContext {
	var p = new(CallParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_callParam

	return p
}

func (s *CallParamContext) GetParser() antlr.Parser { return s.parser }

func (s *CallParamContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CallParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCallParam(s)
	}
}

func (s *CallParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCallParam(s)
	}
}

func (p *BSLParser) CallParam() (localctx ICallParamContext) {
	this := p
	_ = this

	localctx = NewCallParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, BSLParserRULE_callParam)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(738)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(737)
			p.Expression()
		}

	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllMember() []IMemberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberContext); ok {
			len++
		}
	}

	tst := make([]IMemberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberContext); ok {
			tst[i] = t.(IMemberContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Member(i int) IMemberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberContext)
}

func (s *ExpressionContext) AllOperation() []IOperationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperationContext); ok {
			len++
		}
	}

	tst := make([]IOperationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperationContext); ok {
			tst[i] = t.(IOperationContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Operation(i int) IOperationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperationContext)
}

func (s *ExpressionContext) AllPreprocessor() []IPreprocessorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPreprocessorContext); ok {
			len++
		}
	}

	tst := make([]IPreprocessorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPreprocessorContext); ok {
			tst[i] = t.(IPreprocessorContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) Preprocessor(i int) IPreprocessorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPreprocessorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPreprocessorContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *BSLParser) Expression() (localctx IExpressionContext) {
	this := p
	_ = this

	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, BSLParserRULE_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(740)
		p.Member()
	}
	p.SetState(763)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(744)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == BSLParserHASH {
				{
					p.SetState(741)
					p.Preprocessor()
				}

				p.SetState(746)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(747)
				p.Operation()
			}
			p.SetState(751)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == BSLParserHASH {
				{
					p.SetState(748)
					p.Preprocessor()
				}

				p.SetState(753)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(754)
				p.Member()
			}
			p.SetState(758)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(755)
						p.Preprocessor()
					}

				}
				p.SetState(760)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
			}

		}
		p.SetState(765)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
	}

	return localctx
}

// IOperationContext is an interface to support dynamic dispatch.
type IOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOperationContext differentiates from other interfaces.
	IsOperationContext()
}

type OperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperationContext() *OperationContext {
	var p = new(OperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_operation
	return p
}

func (*OperationContext) IsOperationContext() {}

func NewOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperationContext {
	var p = new(OperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_operation

	return p
}

func (s *OperationContext) GetParser() antlr.Parser { return s.parser }

func (s *OperationContext) PLUS() antlr.TerminalNode {
	return s.GetToken(BSLParserPLUS, 0)
}

func (s *OperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BSLParserMINUS, 0)
}

func (s *OperationContext) MUL() antlr.TerminalNode {
	return s.GetToken(BSLParserMUL, 0)
}

func (s *OperationContext) QUOTIENT() antlr.TerminalNode {
	return s.GetToken(BSLParserQUOTIENT, 0)
}

func (s *OperationContext) MODULO() antlr.TerminalNode {
	return s.GetToken(BSLParserMODULO, 0)
}

func (s *OperationContext) BoolOperation() IBoolOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolOperationContext)
}

func (s *OperationContext) CompareOperation() ICompareOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompareOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompareOperationContext)
}

func (s *OperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterOperation(s)
	}
}

func (s *OperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitOperation(s)
	}
}

func (p *BSLParser) Operation() (localctx IOperationContext) {
	this := p
	_ = this

	localctx = NewOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, BSLParserRULE_operation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(773)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserPLUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(766)
			p.Match(BSLParserPLUS)
		}

	case BSLParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(767)
			p.Match(BSLParserMINUS)
		}

	case BSLParserMUL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(768)
			p.Match(BSLParserMUL)
		}

	case BSLParserQUOTIENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(769)
			p.Match(BSLParserQUOTIENT)
		}

	case BSLParserMODULO:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(770)
			p.Match(BSLParserMODULO)
		}

	case BSLParserOR_KEYWORD, BSLParserAND_KEYWORD:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(771)
			p.BoolOperation()
		}

	case BSLParserASSIGN, BSLParserLESS_OR_EQUAL, BSLParserNOT_EQUAL, BSLParserLESS, BSLParserGREATER_OR_EQUAL, BSLParserGREATER:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(772)
			p.CompareOperation()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICompareOperationContext is an interface to support dynamic dispatch.
type ICompareOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompareOperationContext differentiates from other interfaces.
	IsCompareOperationContext()
}

type CompareOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompareOperationContext() *CompareOperationContext {
	var p = new(CompareOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_compareOperation
	return p
}

func (*CompareOperationContext) IsCompareOperationContext() {}

func NewCompareOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompareOperationContext {
	var p = new(CompareOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_compareOperation

	return p
}

func (s *CompareOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *CompareOperationContext) LESS() antlr.TerminalNode {
	return s.GetToken(BSLParserLESS, 0)
}

func (s *CompareOperationContext) LESS_OR_EQUAL() antlr.TerminalNode {
	return s.GetToken(BSLParserLESS_OR_EQUAL, 0)
}

func (s *CompareOperationContext) GREATER() antlr.TerminalNode {
	return s.GetToken(BSLParserGREATER, 0)
}

func (s *CompareOperationContext) GREATER_OR_EQUAL() antlr.TerminalNode {
	return s.GetToken(BSLParserGREATER_OR_EQUAL, 0)
}

func (s *CompareOperationContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(BSLParserASSIGN, 0)
}

func (s *CompareOperationContext) NOT_EQUAL() antlr.TerminalNode {
	return s.GetToken(BSLParserNOT_EQUAL, 0)
}

func (s *CompareOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompareOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompareOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCompareOperation(s)
	}
}

func (s *CompareOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCompareOperation(s)
	}
}

func (p *BSLParser) CompareOperation() (localctx ICompareOperationContext) {
	this := p
	_ = this

	localctx = NewCompareOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, BSLParserRULE_compareOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&509952) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IBoolOperationContext is an interface to support dynamic dispatch.
type IBoolOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolOperationContext differentiates from other interfaces.
	IsBoolOperationContext()
}

type BoolOperationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolOperationContext() *BoolOperationContext {
	var p = new(BoolOperationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_boolOperation
	return p
}

func (*BoolOperationContext) IsBoolOperationContext() {}

func NewBoolOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolOperationContext {
	var p = new(BoolOperationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_boolOperation

	return p
}

func (s *BoolOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolOperationContext) OR_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserOR_KEYWORD, 0)
}

func (s *BoolOperationContext) AND_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserAND_KEYWORD, 0)
}

func (s *BoolOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterBoolOperation(s)
	}
}

func (s *BoolOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitBoolOperation(s)
	}
}

func (p *BSLParser) BoolOperation() (localctx IBoolOperationContext) {
	this := p
	_ = this

	localctx = NewBoolOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, BSLParserRULE_boolOperation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		_la = p.GetTokenStream().LA(1)

		if !(_la == BSLParserOR_KEYWORD || _la == BSLParserAND_KEYWORD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IUnaryModifierContext is an interface to support dynamic dispatch.
type IUnaryModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnaryModifierContext differentiates from other interfaces.
	IsUnaryModifierContext()
}

type UnaryModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryModifierContext() *UnaryModifierContext {
	var p = new(UnaryModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_unaryModifier
	return p
}

func (*UnaryModifierContext) IsUnaryModifierContext() {}

func NewUnaryModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryModifierContext {
	var p = new(UnaryModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_unaryModifier

	return p
}

func (s *UnaryModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryModifierContext) NOT_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserNOT_KEYWORD, 0)
}

func (s *UnaryModifierContext) MINUS() antlr.TerminalNode {
	return s.GetToken(BSLParserMINUS, 0)
}

func (s *UnaryModifierContext) PLUS() antlr.TerminalNode {
	return s.GetToken(BSLParserPLUS, 0)
}

func (s *UnaryModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterUnaryModifier(s)
	}
}

func (s *UnaryModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitUnaryModifier(s)
	}
}

func (p *BSLParser) UnaryModifier() (localctx IUnaryModifierContext) {
	this := p
	_ = this

	localctx = NewUnaryModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, BSLParserRULE_unaryModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-12)) & ^0x3f) == 0 && ((int64(1)<<(_la-12))&18014398509481987) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IMemberContext is an interface to support dynamic dispatch.
type IMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberContext differentiates from other interfaces.
	IsMemberContext()
}

type MemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberContext() *MemberContext {
	var p = new(MemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_member
	return p
}

func (*MemberContext) IsMemberContext() {}

func NewMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberContext {
	var p = new(MemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_member

	return p
}

func (s *MemberContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberContext) ConstValue() IConstValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstValueContext)
}

func (s *MemberContext) ComplexIdentifier() IComplexIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComplexIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComplexIdentifierContext)
}

func (s *MemberContext) WaitExpression() IWaitExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWaitExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWaitExpressionContext)
}

func (s *MemberContext) UnaryModifier() IUnaryModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryModifierContext)
}

func (s *MemberContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *MemberContext) GlobalMethodCall() IGlobalMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalMethodCallContext)
}

func (s *MemberContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserLPAREN, 0)
}

func (s *MemberContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MemberContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserRPAREN, 0)
}

func (s *MemberContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *MemberContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *MemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterMember(s)
	}
}

func (s *MemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitMember(s)
	}
}

func (p *BSLParser) Member() (localctx IMemberContext) {
	this := p
	_ = this

	localctx = NewMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, BSLParserRULE_member)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(781)
			p.UnaryModifier()
		}

	}
	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(784)
			p.ConstValue()
		}

	case 2:
		{
			p.SetState(785)
			p.ComplexIdentifier()
		}

	case 3:
		{
			p.SetState(786)
			p.Match(BSLParserLPAREN)
		}
		{
			p.SetState(787)
			p.Expression()
		}
		{
			p.SetState(788)
			p.Match(BSLParserRPAREN)
		}

		p.SetState(793)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == BSLParserDOT || _la == BSLParserLBRACK {
			{
				p.SetState(790)
				p.Modifier()
			}

			p.SetState(795)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(796)
				p.Match(BSLParserIDENTIFIER)
			}

		case 2:
			{
				p.SetState(797)
				p.GlobalMethodCall()
			}

		}

	case 5:
		{
			p.SetState(800)
			p.WaitExpression()
		}

	}

	return localctx
}

// INewwExpressionContext is an interface to support dynamic dispatch.
type INewwExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNewwExpressionContext differentiates from other interfaces.
	IsNewwExpressionContext()
}

type NewwExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewwExpressionContext() *NewwExpressionContext {
	var p = new(NewwExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_newwExpression
	return p
}

func (*NewwExpressionContext) IsNewwExpressionContext() {}

func NewNewwExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewwExpressionContext {
	var p = new(NewwExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_newwExpression

	return p
}

func (s *NewwExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NewwExpressionContext) NEW_KEYWORD() antlr.TerminalNode {
	return s.GetToken(BSLParserNEW_KEYWORD, 0)
}

func (s *NewwExpressionContext) TypeName() ITypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameContext)
}

func (s *NewwExpressionContext) DoCall() IDoCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoCallContext)
}

func (s *NewwExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewwExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewwExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterNewwExpression(s)
	}
}

func (s *NewwExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitNewwExpression(s)
	}
}

func (p *BSLParser) NewwExpression() (localctx INewwExpressionContext) {
	this := p
	_ = this

	localctx = NewNewwExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, BSLParserRULE_newwExpression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(810)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(803)
			p.Match(BSLParserNEW_KEYWORD)
		}
		{
			p.SetState(804)
			p.TypeName()
		}
		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == BSLParserLPAREN {
			{
				p.SetState(805)
				p.DoCall()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.Match(BSLParserNEW_KEYWORD)
		}
		{
			p.SetState(809)
			p.DoCall()
		}

	}

	return localctx
}

// ITypeNameContext is an interface to support dynamic dispatch.
type ITypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTypeNameContext differentiates from other interfaces.
	IsTypeNameContext()
}

type TypeNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameContext() *TypeNameContext {
	var p = new(TypeNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_typeName
	return p
}

func (*TypeNameContext) IsTypeNameContext() {}

func NewTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameContext {
	var p = new(TypeNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_typeName

	return p
}

func (s *TypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *TypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterTypeName(s)
	}
}

func (s *TypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitTypeName(s)
	}
}

func (p *BSLParser) TypeName() (localctx ITypeNameContext) {
	this := p
	_ = this

	localctx = NewTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, BSLParserRULE_typeName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(812)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// IMethodCallContext is an interface to support dynamic dispatch.
type IMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodCallContext differentiates from other interfaces.
	IsMethodCallContext()
}

type MethodCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodCallContext() *MethodCallContext {
	var p = new(MethodCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_methodCall
	return p
}

func (*MethodCallContext) IsMethodCallContext() {}

func NewMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodCallContext {
	var p = new(MethodCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_methodCall

	return p
}

func (s *MethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodCallContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *MethodCallContext) DoCall() IDoCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoCallContext)
}

func (s *MethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterMethodCall(s)
	}
}

func (s *MethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitMethodCall(s)
	}
}

func (p *BSLParser) MethodCall() (localctx IMethodCallContext) {
	this := p
	_ = this

	localctx = NewMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, BSLParserRULE_methodCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.MethodName()
	}
	{
		p.SetState(815)
		p.DoCall()
	}

	return localctx
}

// IGlobalMethodCallContext is an interface to support dynamic dispatch.
type IGlobalMethodCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalMethodCallContext differentiates from other interfaces.
	IsGlobalMethodCallContext()
}

type GlobalMethodCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalMethodCallContext() *GlobalMethodCallContext {
	var p = new(GlobalMethodCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_globalMethodCall
	return p
}

func (*GlobalMethodCallContext) IsGlobalMethodCallContext() {}

func NewGlobalMethodCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalMethodCallContext {
	var p = new(GlobalMethodCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_globalMethodCall

	return p
}

func (s *GlobalMethodCallContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalMethodCallContext) MethodName() IMethodNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodNameContext)
}

func (s *GlobalMethodCallContext) DoCall() IDoCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoCallContext)
}

func (s *GlobalMethodCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalMethodCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalMethodCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterGlobalMethodCall(s)
	}
}

func (s *GlobalMethodCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitGlobalMethodCall(s)
	}
}

func (p *BSLParser) GlobalMethodCall() (localctx IGlobalMethodCallContext) {
	this := p
	_ = this

	localctx = NewGlobalMethodCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, BSLParserRULE_globalMethodCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.MethodName()
	}
	{
		p.SetState(818)
		p.DoCall()
	}

	return localctx
}

// IMethodNameContext is an interface to support dynamic dispatch.
type IMethodNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMethodNameContext differentiates from other interfaces.
	IsMethodNameContext()
}

type MethodNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMethodNameContext() *MethodNameContext {
	var p = new(MethodNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_methodName
	return p
}

func (*MethodNameContext) IsMethodNameContext() {}

func NewMethodNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MethodNameContext {
	var p = new(MethodNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_methodName

	return p
}

func (s *MethodNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MethodNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *MethodNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MethodNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MethodNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterMethodName(s)
	}
}

func (s *MethodNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitMethodName(s)
	}
}

func (p *BSLParser) MethodName() (localctx IMethodNameContext) {
	this := p
	_ = this

	localctx = NewMethodNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, BSLParserRULE_methodName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// IComplexIdentifierContext is an interface to support dynamic dispatch.
type IComplexIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComplexIdentifierContext differentiates from other interfaces.
	IsComplexIdentifierContext()
}

type ComplexIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplexIdentifierContext() *ComplexIdentifierContext {
	var p = new(ComplexIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_complexIdentifier
	return p
}

func (*ComplexIdentifierContext) IsComplexIdentifierContext() {}

func NewComplexIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComplexIdentifierContext {
	var p = new(ComplexIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_complexIdentifier

	return p
}

func (s *ComplexIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ComplexIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *ComplexIdentifierContext) NewwExpression() INewwExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewwExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewwExpressionContext)
}

func (s *ComplexIdentifierContext) TernaryOperator() ITernaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryOperatorContext)
}

func (s *ComplexIdentifierContext) GlobalMethodCall() IGlobalMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalMethodCallContext)
}

func (s *ComplexIdentifierContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *ComplexIdentifierContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *ComplexIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComplexIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComplexIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterComplexIdentifier(s)
	}
}

func (s *ComplexIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitComplexIdentifier(s)
	}
}

func (p *BSLParser) ComplexIdentifier() (localctx IComplexIdentifierContext) {
	this := p
	_ = this

	localctx = NewComplexIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, BSLParserRULE_complexIdentifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(826)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(822)
			p.Match(BSLParserIDENTIFIER)
		}

	case 2:
		{
			p.SetState(823)
			p.NewwExpression()
		}

	case 3:
		{
			p.SetState(824)
			p.TernaryOperator()
		}

	case 4:
		{
			p.SetState(825)
			p.GlobalMethodCall()
		}

	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == BSLParserDOT || _la == BSLParserLBRACK {
		{
			p.SetState(828)
			p.Modifier()
		}

		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IModifierContext is an interface to support dynamic dispatch.
type IModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModifierContext differentiates from other interfaces.
	IsModifierContext()
}

type ModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifierContext() *ModifierContext {
	var p = new(ModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_modifier
	return p
}

func (*ModifierContext) IsModifierContext() {}

func NewModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifierContext {
	var p = new(ModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_modifier

	return p
}

func (s *ModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifierContext) AccessProperty() IAccessPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessPropertyContext)
}

func (s *ModifierContext) AccessIndex() IAccessIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessIndexContext)
}

func (s *ModifierContext) AccessCall() IAccessCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessCallContext)
}

func (s *ModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterModifier(s)
	}
}

func (s *ModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitModifier(s)
	}
}

func (p *BSLParser) Modifier() (localctx IModifierContext) {
	this := p
	_ = this

	localctx = NewModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, BSLParserRULE_modifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(834)
			p.AccessProperty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(835)
			p.AccessIndex()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(836)
			p.AccessCall()
		}

	}

	return localctx
}

// IAcceptorContext is an interface to support dynamic dispatch.
type IAcceptorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptorContext differentiates from other interfaces.
	IsAcceptorContext()
}

type AcceptorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptorContext() *AcceptorContext {
	var p = new(AcceptorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_acceptor
	return p
}

func (*AcceptorContext) IsAcceptorContext() {}

func NewAcceptorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptorContext {
	var p = new(AcceptorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_acceptor

	return p
}

func (s *AcceptorContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptorContext) AccessProperty() IAccessPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessPropertyContext)
}

func (s *AcceptorContext) AccessIndex() IAccessIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessIndexContext)
}

func (s *AcceptorContext) AllModifier() []IModifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IModifierContext); ok {
			len++
		}
	}

	tst := make([]IModifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IModifierContext); ok {
			tst[i] = t.(IModifierContext)
			i++
		}
	}

	return tst
}

func (s *AcceptorContext) Modifier(i int) IModifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifierContext)
}

func (s *AcceptorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAcceptor(s)
	}
}

func (s *AcceptorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAcceptor(s)
	}
}

func (p *BSLParser) Acceptor() (localctx IAcceptorContext) {
	this := p
	_ = this

	localctx = NewAcceptorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, BSLParserRULE_acceptor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(842)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(839)
				p.Modifier()
			}

		}
		p.SetState(844)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext())
	}
	p.SetState(847)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case BSLParserDOT:
		{
			p.SetState(845)
			p.AccessProperty()
		}

	case BSLParserLBRACK:
		{
			p.SetState(846)
			p.AccessIndex()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILValueContext is an interface to support dynamic dispatch.
type ILValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLValueContext differentiates from other interfaces.
	IsLValueContext()
}

type LValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLValueContext() *LValueContext {
	var p = new(LValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_lValue
	return p
}

func (*LValueContext) IsLValueContext() {}

func NewLValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LValueContext {
	var p = new(LValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_lValue

	return p
}

func (s *LValueContext) GetParser() antlr.Parser { return s.parser }

func (s *LValueContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *LValueContext) GlobalMethodCall() IGlobalMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalMethodCallContext)
}

func (s *LValueContext) Acceptor() IAcceptorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptorContext)
}

func (s *LValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterLValue(s)
	}
}

func (s *LValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitLValue(s)
	}
}

func (p *BSLParser) LValue() (localctx ILValueContext) {
	this := p
	_ = this

	localctx = NewLValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, BSLParserRULE_lValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(849)
			p.Match(BSLParserIDENTIFIER)
		}

	case 2:
		{
			p.SetState(850)
			p.GlobalMethodCall()
		}

	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == BSLParserDOT || _la == BSLParserLBRACK {
		{
			p.SetState(853)
			p.Acceptor()
		}

	}

	return localctx
}

// IAccessCallContext is an interface to support dynamic dispatch.
type IAccessCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessCallContext differentiates from other interfaces.
	IsAccessCallContext()
}

type AccessCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessCallContext() *AccessCallContext {
	var p = new(AccessCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_accessCall
	return p
}

func (*AccessCallContext) IsAccessCallContext() {}

func NewAccessCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessCallContext {
	var p = new(AccessCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_accessCall

	return p
}

func (s *AccessCallContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessCallContext) DOT() antlr.TerminalNode {
	return s.GetToken(BSLParserDOT, 0)
}

func (s *AccessCallContext) MethodCall() IMethodCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMethodCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMethodCallContext)
}

func (s *AccessCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAccessCall(s)
	}
}

func (s *AccessCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAccessCall(s)
	}
}

func (p *BSLParser) AccessCall() (localctx IAccessCallContext) {
	this := p
	_ = this

	localctx = NewAccessCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, BSLParserRULE_accessCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.Match(BSLParserDOT)
	}
	{
		p.SetState(857)
		p.MethodCall()
	}

	return localctx
}

// IAccessIndexContext is an interface to support dynamic dispatch.
type IAccessIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessIndexContext differentiates from other interfaces.
	IsAccessIndexContext()
}

type AccessIndexContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessIndexContext() *AccessIndexContext {
	var p = new(AccessIndexContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_accessIndex
	return p
}

func (*AccessIndexContext) IsAccessIndexContext() {}

func NewAccessIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessIndexContext {
	var p = new(AccessIndexContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_accessIndex

	return p
}

func (s *AccessIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessIndexContext) LBRACK() antlr.TerminalNode {
	return s.GetToken(BSLParserLBRACK, 0)
}

func (s *AccessIndexContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AccessIndexContext) RBRACK() antlr.TerminalNode {
	return s.GetToken(BSLParserRBRACK, 0)
}

func (s *AccessIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAccessIndex(s)
	}
}

func (s *AccessIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAccessIndex(s)
	}
}

func (p *BSLParser) AccessIndex() (localctx IAccessIndexContext) {
	this := p
	_ = this

	localctx = NewAccessIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, BSLParserRULE_accessIndex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(859)
		p.Match(BSLParserLBRACK)
	}
	{
		p.SetState(860)
		p.Expression()
	}
	{
		p.SetState(861)
		p.Match(BSLParserRBRACK)
	}

	return localctx
}

// IAccessPropertyContext is an interface to support dynamic dispatch.
type IAccessPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessPropertyContext differentiates from other interfaces.
	IsAccessPropertyContext()
}

type AccessPropertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessPropertyContext() *AccessPropertyContext {
	var p = new(AccessPropertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_accessProperty
	return p
}

func (*AccessPropertyContext) IsAccessPropertyContext() {}

func NewAccessPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessPropertyContext {
	var p = new(AccessPropertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_accessProperty

	return p
}

func (s *AccessPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessPropertyContext) DOT() antlr.TerminalNode {
	return s.GetToken(BSLParserDOT, 0)
}

func (s *AccessPropertyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(BSLParserIDENTIFIER, 0)
}

func (s *AccessPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterAccessProperty(s)
	}
}

func (s *AccessPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitAccessProperty(s)
	}
}

func (p *BSLParser) AccessProperty() (localctx IAccessPropertyContext) {
	this := p
	_ = this

	localctx = NewAccessPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, BSLParserRULE_accessProperty)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(863)
		p.Match(BSLParserDOT)
	}
	{
		p.SetState(864)
		p.Match(BSLParserIDENTIFIER)
	}

	return localctx
}

// IDoCallContext is an interface to support dynamic dispatch.
type IDoCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDoCallContext differentiates from other interfaces.
	IsDoCallContext()
}

type DoCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoCallContext() *DoCallContext {
	var p = new(DoCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_doCall
	return p
}

func (*DoCallContext) IsDoCallContext() {}

func NewDoCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoCallContext {
	var p = new(DoCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_doCall

	return p
}

func (s *DoCallContext) GetParser() antlr.Parser { return s.parser }

func (s *DoCallContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserLPAREN, 0)
}

func (s *DoCallContext) CallParamList() ICallParamListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallParamListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallParamListContext)
}

func (s *DoCallContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(BSLParserRPAREN, 0)
}

func (s *DoCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterDoCall(s)
	}
}

func (s *DoCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitDoCall(s)
	}
}

func (p *BSLParser) DoCall() (localctx IDoCallContext) {
	this := p
	_ = this

	localctx = NewDoCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, BSLParserRULE_doCall)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(866)
		p.Match(BSLParserLPAREN)
	}
	{
		p.SetState(867)
		p.CallParamList()
	}
	{
		p.SetState(868)
		p.Match(BSLParserRPAREN)
	}

	return localctx
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = BSLParserRULE_compoundStatement
	return p
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = BSLParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *CompoundStatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *CompoundStatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *CompoundStatementContext) ForEachStatement() IForEachStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForEachStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForEachStatementContext)
}

func (s *CompoundStatementContext) TryStatement() ITryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryStatementContext)
}

func (s *CompoundStatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *CompoundStatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *CompoundStatementContext) BreakStatement() IBreakStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBreakStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBreakStatementContext)
}

func (s *CompoundStatementContext) RaiseStatement() IRaiseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRaiseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRaiseStatementContext)
}

func (s *CompoundStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *CompoundStatementContext) GotoStatement() IGotoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGotoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGotoStatementContext)
}

func (s *CompoundStatementContext) AddHandlerStatement() IAddHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddHandlerStatementContext)
}

func (s *CompoundStatementContext) RemoveHandlerStatement() IRemoveHandlerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemoveHandlerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemoveHandlerStatementContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(BSLParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (p *BSLParser) CompoundStatement() (localctx ICompoundStatementContext) {
	this := p
	_ = this

	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, BSLParserRULE_compoundStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(870)
			p.IfStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(871)
			p.WhileStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(872)
			p.ForStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(873)
			p.ForEachStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(874)
			p.TryStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(875)
			p.ReturnStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(876)
			p.ContinueStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(877)
			p.BreakStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(878)
			p.RaiseStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(879)
			p.ExecuteStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(880)
			p.GotoStatement()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(881)
			p.AddHandlerStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(882)
			p.RemoveHandlerStatement()
		}

	}

	return localctx
}
